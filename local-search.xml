<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>由 certbot 切换到 acme.sh, 使用acme.sh进行SSL证书申请</title>
    <link href="/2025/12/20/blog/other/use_acme_sh/"/>
    <url>/2025/12/20/blog/other/use_acme_sh/</url>
    
    <content type="html"><![CDATA[<p>certbot 用来申请SSL证书也是极好的，够用的，<a href="http://acme.sh">acme.sh</a> 很多人推荐，我自己也star了好多年，一直拖着想尝试，最近试了下，用起来还是不错，</p><p>github地址：<a href="https://github.com/acmesh-official/acme.sh">https://github.com/acmesh-official/acme.sh</a></p><h3 id="nginx配置">nginx配置</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123; <br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>; <br>    <span class="hljs-attribute">server_name</span> api.xxxxx.cn; <br>    <span class="hljs-section">location</span> / &#123; <br>    <span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:5015; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="申请证书">申请证书</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">acme.sh --issue --nginx -d  api.xxxx.cn --force<br></code></pre></td></tr></table></figure><p><a href="http://acme.sh">acme.sh</a> 脚本默认 CA 服务器是 <a href="https://acme.zerossl.com/v2/DV90">ZeroSSL</a>, 国内访问经常抽风, 多等等也许会好<br>也可以切换到 <a href="https://letsencrypt.org/">Let’s Encrypt</a>]</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">acme.sh --set-default-ca --server letsencrypt<br></code></pre></td></tr></table></figure><h3 id="安装证书">安装证书</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p /etc/nginx/ssl/api.xxxx.cn<br><br>acme.sh --install-cert -d api.xxxx.cn \<br>--key-file       /etc/nginx/ssl/api.xxxx.cn/key.pem \<br>--fullchain-file /etc/nginx/ssl/api.xxxx.cn/fullchain.pem \<br>--reloadcmd     &quot;nginx -s reload&quot;<br></code></pre></td></tr></table></figure><h3 id="配置nginx">配置nginx</h3><p>配置完毕，重启nginx，然后没啥事儿了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>server &#123;<br>    listen 80;<br>    server_name api.xxxx.cn;<br>    #ACME_NGINX_START<br>    location ~ &quot;^/\.well-known/acme-challenge/([-_a-zA-Z0-9]+)$&quot; &#123;<br>      default_type text/plain;<br>      return 200 &quot;$1.2THoePkTTzFjYUI_9CZXr7mt5Li4ESUg3DtzLyuQsm0&quot;;<br>    &#125;<br>    #NGINX_START<br><br>    return 301 https://$host$request_uri;<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">HTTPS</span><br>server &#123;<br>    listen 443 ssl ;<br>    server_name api.xxxx.cn;<br><br>    ssl_certificate     /etc/nginx/ssl/api.xxxx.cn/fullchain.pem;<br>    ssl_certificate_key /etc/nginx/ssl/api.xxxx.cn/key.pem;<br><br>    ssl_protocols TLSv1.2 TLSv1.3;<br>    ssl_prefer_server_ciphers on;<br><br>    location / &#123;<br>        proxy_pass http://127.0.0.1:5015;<br><br>        proxy_set_header Host $host;<br>        proxy_set_header X-Real-IP $remote_addr;<br>        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br>        proxy_set_header X-Forwarded-Proto https;<br><br>        # WebSocket（安全保留）<br>        proxy_http_version 1.1;<br>        proxy_set_header Upgrade $http_upgrade;<br>        proxy_set_header Connection &quot;upgrade&quot;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>acme.sh</tag>
      
      <tag>SSL</tag>
      
      <tag>HTTPS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GPT-5 新特性与应用</title>
    <link href="/2025/08/11/blog/ai/llm/gpt-5/"/>
    <url>/2025/08/11/blog/ai/llm/gpt-5/</url>
    
    <content type="html"><![CDATA[<h3 id="gpt-5">gpt-5:</h3><p><a href="https://platform.openai.com/docs/guides/latest-model?reasoning-effort-mode=responses#prompting-guidance">https://platform.openai.com/docs/guides/latest-model?reasoning-effort-mode=responses#prompting-guidance</a><br><a href="https://cookbook.openai.com/examples/gpt-5/gpt-5_new_params_and_tools#4-minimal-reasoning">https://cookbook.openai.com/examples/gpt-5/gpt-5_new_params_and_tools#4-minimal-reasoning</a></p><h4 id="缓存-旧概念">缓存(旧概念):</h4><p><a href="https://platform.openai.com/docs/guides/prompt-caching">https://platform.openai.com/docs/guides/prompt-caching</a></p><p>OpenAI 会将 API 请求路由到最近处理过相同提示的服务器上，从而以比从头开始处理更低的成本和更快的速度完成请求。这种方法可将延迟降低高达 80%，成本降低高达 75%</p><p>当提示词达到或超过 1024 个 token 时，缓存将自动启用。当发起 API 请求时，将发生以下步骤：</p><ul><li>缓存路由：<ul><li>请求会根据提示词初始前缀的哈希值被路由到特定机器。哈希通常使用前 256 个 token，但具体长度可能因模型而异。</li><li>如果提供了prompt_cache_key参数，它将与前缀哈希值结合使用，从而允许影响路由并提高缓存命中率。当多个请求共享较长的公共前缀时，这一点尤为有益。</li><li>如果针对相同前缀和 prompt_cache_key 组合的请求超过一定频率（约每分钟 15 次），部分请求可能会溢出并被路由到其他机器，从而降低缓存效率。</li></ul></li><li>缓存查找：系统会检查所选机器上的缓存中是否存在提示词的初始部分（前缀）。</li><li>缓存命中：如果找到匹配的前缀，系统将使用缓存结果。这将显著降低延迟并减少成本。</li><li>缓存未命中：如果未找到匹配的前缀，系统将处理完整提示词，并在该机器上缓存其前缀，供后续请求使用。<br>已缓存的前缀通常在连续 5 到 10 分钟无活动后失效。但在非高峰时段，缓存可能最长保留一小时。</li></ul><h4 id="记忆-旧概念-：">记忆(旧概念)：</h4><p><a href="https://help.openai.com/en/collections/8471548-memory">https://help.openai.com/en/collections/8471548-memory</a><br><a href="https://www.tomsguide.com/ai/chatgpt-5-features-heres-the-5-upgrades-i-would-try-first">https://www.tomsguide.com/ai/chatgpt-5-features-heres-the-5-upgrades-i-would-try-first</a></p><h4 id="性格">性格:</h4><p><a href="https://help.openai.com/en/articles/11899719-customizing-your-chatgpt-personality">https://help.openai.com/en/articles/11899719-customizing-your-chatgpt-personality</a></p><p><strong>记忆和性格都是在GPT自家的应用中使用的</strong></p><h3 id="模型">模型</h3><table><thead><tr><th>模型</th><th>特点</th><th>参数</th><th></th></tr></thead><tbody><tr><td>GPT-5</td><td>在各个领域进行编码、推理和代理任务的旗舰模型</td><td>400,000 context window <br />128,000 max output tokens  <br /> May 31, 2024 knowledge cutoff <br /> Reasoning token support</td><td></td></tr><tr><td>GPT-5 mini</td><td>一个更快、更具成本效益的版本。非常适合定义明确的任务和精确的提示。</td><td>400,000 context window <br />128,000 max output tokens  <br /> May 31, 2024 knowledge cutoff <br /> Reasoning token support</td><td></td></tr><tr><td>GPT-5 nano</td><td>最快、最经济的 GPT-5 版本。非常适合摘要和分类任务</td><td>400,000 context window <br />128,000 max output tokens  <br /> May 31, 2024 knowledge cutoff <br /> Reasoning token support</td><td></td></tr></tbody></table><h3 id="价格对比">价格对比</h3><table><thead><tr><th>模型</th><th>输入</th><th>缓存</th><th>输出</th></tr></thead><tbody><tr><td>GPT-5</td><td>$1.25</td><td>$0.13</td><td>$10.00</td></tr><tr><td>GPT-5 mini</td><td>$0.25</td><td>$0.03</td><td>$2.00</td></tr><tr><td>GPT-5 nano</td><td>$0.05</td><td>$0.01</td><td>$0.40</td></tr><tr><td>GPT-4o</td><td>$2.50</td><td>$1.25</td><td>$10.00</td></tr><tr><td>GPT-4.1</td><td>$2.00</td><td>$0.50</td><td>$8.00</td></tr><tr><td>o3-mini</td><td>$1.10</td><td>$0.55</td><td>$4.40</td></tr></tbody></table><h2 id="接口调用新参数">接口调用新参数</h2><h3 id="1-verbosity-参数">1.  <code>verbosity</code> 参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>client = OpenAI()<br><span class="hljs-keyword">for</span> verbosity <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;low&quot;</span>, <span class="hljs-string">&quot;medium&quot;</span>, <span class="hljs-string">&quot;high&quot;</span>]:<br>    response = client.responses.create(<br>        model=<span class="hljs-string">&quot;gpt-5-mini&quot;</span>,<br>        <span class="hljs-built_in">input</span>=<span class="hljs-string">&quot;写一首关于一个男孩和他的第一只宠物狗的诗&quot;</span>,<br>        text=&#123;<span class="hljs-string">&quot;verbosity&quot;</span>: verbosity&#125;<br>    )<br></code></pre></td></tr></table></figure><p>可以在不改变底层提示词的情况下，稳定地同时调整模型输出的长度和深度，并且保持正确性和推理质量。</p><p>low: 简洁的用户体验，文字最少<br>medium(默认值): 细节与简洁平衡<br>high: 内容详尽，适合审查、教学。</p><p>测试使用token消耗比重：<br>low:medium:high —  <strong>424:530:1072</strong></p><h3 id="2-自由形式函数调用-Freeform-Function-Calling">2. 自由形式函数调用 Freeform Function Calling</h3><h4 id="示例">示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>client = OpenAI()<br><br>response = client.responses.create(<br>    model=<span class="hljs-string">&quot;gpt-5-mini&quot;</span>,<br>    <span class="hljs-built_in">input</span>=<span class="hljs-string">&quot;请使用code_exec工具计算 100 以内的质数之和。&quot;</span>,<br>    text=&#123;<span class="hljs-string">&quot;format&quot;</span>: &#123;<span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>&#125;&#125;,<br>    tools=[<br>        &#123;<br>            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;custom&quot;</span>,<br>            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;code_exec&quot;</span>,<br>            <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;Executes arbitrary python code&quot;</span>,<br>        &#125;<br>    ]<br>)<br></code></pre></td></tr></table></figure><p>GPT-5 中的自由形式工具调用允许将原始文本载荷——例如 Python 脚本、SQL 查询或配置文件——直接发送到自定义工具，而无需使用 JSON 封装<br>(本质就是将一段文本交给工具处理)</p><h4 id="对比function-工具-gpt会返回json格式文本">对比function 工具(gpt会返回json格式文本)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">tools = [&#123;<br>    <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;function&quot;</span>,<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;get_weather&quot;</span>,<br>    <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;Get current temperature for provided coordinates in celsius.&quot;</span>,<br>    <span class="hljs-string">&quot;parameters&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;object&quot;</span>,<br>        <span class="hljs-string">&quot;properties&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;latitude&quot;</span>: &#123;<span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;number&quot;</span>&#125;,<br>            <span class="hljs-string">&quot;longitude&quot;</span>: &#123;<span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;number&quot;</span>&#125;<br>        &#125;,<br>        <span class="hljs-string">&quot;required&quot;</span>: [<span class="hljs-string">&quot;latitude&quot;</span>, <span class="hljs-string">&quot;longitude&quot;</span>],<br>        <span class="hljs-string">&quot;additionalProperties&quot;</span>: <span class="hljs-literal">False</span><br>    &#125;,<br>    <span class="hljs-string">&quot;strict&quot;</span>: <span class="hljs-literal">True</span><br>&#125;]<br></code></pre></td></tr></table></figure><h3 id="3-上下文无关语法-Context‑Free-Grammar-CFG">3. 上下文无关语法 Context‑Free Grammar (CFG)</h3><p>在custom tools中，可以使用上下文无关语法 CFG 限制输出， 确保自定义工具的输入符合预期。</p><p>“syntax”: “lark”<br>“syntax”: “regex”</p><h4 id="示例-2">示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>client = OpenAI()<br><br>timestamp_grammar_definition = <span class="hljs-string">r&quot;^\d&#123;1&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01]) (?:[01]\d|2[0-3]):[0-5]\d$&quot;</span><br><br>timestamp_prompt = (<br>    <span class="hljs-string">&quot;Call the timestamp_grammar to save a timestamp for August 7th 2025 at 10AM.&quot;</span><br>)<br><br>response_mssql = client.responses.create(<br>    model=<span class="hljs-string">&quot;gpt-5&quot;</span>,<br>    <span class="hljs-built_in">input</span>=timestamp_prompt,<br>    text=&#123;<span class="hljs-string">&quot;format&quot;</span>: &#123;<span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>&#125;&#125;,<br>    tools=[<br>        &#123;<br>            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;custom&quot;</span>,<br>            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;timestamp_grammar&quot;</span>,<br>            <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;Saves a timestamp in date + time in 24-hr format.&quot;</span>,<br>            <span class="hljs-string">&quot;format&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;grammar&quot;</span>,<br>                <span class="hljs-string">&quot;syntax&quot;</span>: <span class="hljs-string">&quot;regex&quot;</span>,<br>                <span class="hljs-string">&quot;definition&quot;</span>: timestamp_grammar_definition<br>            &#125;<br>        &#125;,<br>    ],<br>    parallel_tool_calls=<span class="hljs-literal">False</span><br>)<br></code></pre></td></tr></table></figure><h3 id="4-Minimal-Reasoning">4.  Minimal Reasoning</h3><p>Minimal reasoning 通过使用极少或不使用推理 token 来运行 GPT-5，以最大限度地降低延迟并加快首字输出时间。适用于无需解释的确定性、轻量级任务（如信息提取、格式化、简短重写、简单分类）。若不指定 effort 参数，默认为 medium；当您优先考虑速度而非深入推理时，请显式设置为 minimal。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openai <span class="hljs-keyword">import</span> OpenAI<br><br>client = OpenAI()<br><br>prompt = <span class="hljs-string">&quot;Classify sentiment of the review as positive|neutral|negative. Return one word only.&quot;</span> <br><br><br>response = client.responses.create(<br>    model=<span class="hljs-string">&quot;gpt-5&quot;</span>,<br>    <span class="hljs-built_in">input</span>= [&#123; <span class="hljs-string">&#x27;role&#x27;</span>: <span class="hljs-string">&#x27;developer&#x27;</span>, <span class="hljs-string">&#x27;content&#x27;</span>: prompt &#125;, <br>            &#123; <span class="hljs-string">&#x27;role&#x27;</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-string">&#x27;content&#x27;</span>: <span class="hljs-string">&#x27;The food that the restaurant was great! I recommend it to everyone.&#x27;</span> &#125;],<br>    reasoning = &#123;<br>        <span class="hljs-string">&quot;effort&quot;</span>: <span class="hljs-string">&quot;minimal&quot;</span><br>    &#125;,<br>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>GPT5</tag>
      
      <tag>OPENAI</tag>
      
      <tag>LLM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开发中遇到的一些有意思的字符</title>
    <link href="/2025/01/19/blog/article/interesting_character/"/>
    <url>/2025/01/19/blog/article/interesting_character/</url>
    
    <content type="html"><![CDATA[<h2 id="1-“Φφ”-这两个字符竟然’相同’">1. “Φφ” 这两个字符竟然’相同’</h2><p>在文本查找工具中,这两个字符相同，原因：“Φ”.lower()==“φ”</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">json.dumps(<span class="hljs-string">&quot;Φφ&quot;</span>)<br><span class="hljs-string">&#x27;&quot;\\u03a6\u03c6&quot;&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="2-len-“ｻﾞ”-2">2. len(“ｻﾞ”) == 2</h2><p>日语中有一些字符看着是一个字，是因为它是两个 Unicode 码点（半角假名+浊音符号）</p>]]></content>
    
    
    
    <tags>
      
      <tag>思考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用python把多个pdf合并为一个pdf文件</title>
    <link href="/2025/01/19/blog/python/pdf_merge/"/>
    <url>/2025/01/19/blog/python/pdf_merge/</url>
    
    <content type="html"><![CDATA[<h5 id="安装PyPDF2">安装PyPDF2</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install PyPDF2<br></code></pre></td></tr></table></figure><h5 id="合并pdf文件">合并pdf文件</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PyPDF2 <span class="hljs-keyword">import</span> PdfMerger<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge_pdfs</span>(<span class="hljs-params">pdf_list, output_file</span>):<br>    merger = PdfMerger()<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">for</span> pdf <span class="hljs-keyword">in</span> pdf_list:<br>            merger.append(pdf)<br>        merger.write(output_file)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;PDF 文件已成功合并并保存为 <span class="hljs-subst">&#123;output_file&#125;</span>&quot;</span>)<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;合并过程中出现错误: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>    <span class="hljs-keyword">finally</span>:<br>        merger.close()<br><br><br>pdf_files = [<span class="hljs-string">&quot;a.pdf&quot;</span>] * <span class="hljs-number">10</span>  <br>output_pdf = <span class="hljs-string">&quot;merged_output.pdf&quot;</span><br>merge_pdfs(pdf_files, output_pdf)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>PDF</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python print() 在 Docker 不输出</title>
    <link href="/2024/10/30/Python/DockerPrintNotData/"/>
    <url>/2024/10/30/Python/DockerPrintNotData/</url>
    
    <content type="html"><![CDATA[<p>print 输出有缓冲</p><p>解决办法</p><ol><li>Dockerfile <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ENV PYTHONUNBUFFERED=1<br></code></pre></td></tr></table></figure></li><li>docker run <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -e PYTHONUNBUFFERED=1<br></code></pre></td></tr></table></figure></li><li>print中的flush=True <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">print(&quot;start&quot;, flush=True)<br></code></pre></td></tr></table></figure></li></ol><p>一个使用python起docker守护进程的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">python3 -m http.server 8000</span><br><br> docker run --name test-run -it -d amazonlinux:2023 python3 -m http.server 8000<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AWS S3 下载文件翻倍占用内存</title>
    <link href="/2024/06/25/blog/other/aws_sdk_DownloadLargeObject/"/>
    <url>/2024/06/25/blog/other/aws_sdk_DownloadLargeObject/</url>
    
    <content type="html"><![CDATA[<p>在aws doc (<a href="https://docs.aws.amazon.com/zh_cn/AmazonS3/latest/userguide/example_s3_Scenario_UsingLargeFiles_section.html">https://docs.aws.amazon.com/zh_cn/AmazonS3/latest/userguide/example_s3_Scenario_UsingLargeFiles_section.html</a>)上面找的下载大文件示例,直接粘贴运行,没问题,提交上线</p><p>源代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// DownloadLargeObject uses a download manager to download an object from a bucket.</span><br><span class="hljs-comment">// The download manager gets the data in parts and writes them to a buffer until all of</span><br><span class="hljs-comment">// the data has been downloaded.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(basics BucketBasics)</span></span> DownloadLargeObject(bucketName <span class="hljs-type">string</span>, objectKey <span class="hljs-type">string</span>) ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">var</span> partMiBs <span class="hljs-type">int64</span> = <span class="hljs-number">10</span><br>    downloader := manager.NewDownloader(basics.S3Client, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(d *manager.Downloader)</span></span> &#123;<br>d.PartSize = partMiBs * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span><br>&#125;)<br>buffer := manager.NewWriteAtBuffer([]<span class="hljs-type">byte</span>&#123;&#125;)<br>_, err := downloader.Download(context.TODO(), buffer, &amp;s3.GetObjectInput&#123;<br>Bucket: aws.String(bucketName),<br>Key:    aws.String(objectKey),<br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;Couldn&#x27;t download large object from %v:%v. Here&#x27;s why: %v\n&quot;</span>,<br>bucketName, objectKey, err)<br>&#125;<br><span class="hljs-keyword">return</span> buffer.Bytes(), err<br>&#125;<br></code></pre></td></tr></table></figure><p>后面客户反馈业务上传500M的文件,接口报错了,查了一下就是服务重启了,本地复现了一下发现下载这个500M的文件,使用的内存却到了2G+,直接内存爆掉,服务重启</p><p>排查了一下发现就是manager.NewWriteAtBuffer这个结构内存,在使用判断切片容量不足的情况下,直接重新新建了一个新的切片,旧的切片没有及时清理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//https://github.com/aws/aws-sdk-go-v2/blob/4ed838eab2a963cb16301501c8b8c3e29dac4c20/feature/s3/manager/types.go#L162</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *WriteAtBuffer)</span></span> WriteAt(p []<span class="hljs-type">byte</span>, pos <span class="hljs-type">int64</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>) &#123;<br>pLen := <span class="hljs-built_in">len</span>(p)<br>expLen := pos + <span class="hljs-type">int64</span>(pLen)<br>b.m.Lock()<br><span class="hljs-keyword">defer</span> b.m.Unlock()<br><span class="hljs-keyword">if</span> <span class="hljs-type">int64</span>(<span class="hljs-built_in">len</span>(b.buf)) &lt; expLen &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-type">int64</span>(<span class="hljs-built_in">cap</span>(b.buf)) &lt; expLen &#123;<br><span class="hljs-keyword">if</span> b.GrowthCoeff &lt; <span class="hljs-number">1</span> &#123;<br>b.GrowthCoeff = <span class="hljs-number">1</span><br>&#125;<br>newBuf := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, expLen, <span class="hljs-type">int64</span>(b.GrowthCoeff*<span class="hljs-type">float64</span>(expLen)))<br><span class="hljs-built_in">copy</span>(newBuf, b.buf)<br>b.buf = newBuf<br>&#125;<br>b.buf = b.buf[:expLen]<br>&#125;<br><span class="hljs-built_in">copy</span>(b.buf[pos:], p)<br><span class="hljs-keyword">return</span> pLen, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>解决办法:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">buffer := manager.NewWriteAtBuffer([]<span class="hljs-type">byte</span>&#123;&#125;)<br></code></pre></td></tr></table></figure><p>获取S3文件的size<br>初始化切片, 直接给到文件对应的大小</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">headInput := &amp;s3.HeadObjectInput&#123;<br>Bucket: bucketName,<br>Key:    objectKey,<br>&#125;<br><br>headObject, err := s3c.client.HeadObject(context.TODO(), headInput)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>buf := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, ptr.ToInt64(headObject.ContentLength))<br>buffer := manager.NewWriteAtBuffer(buf)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>aws</tag>
      
      <tag>s3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 读写分离</title>
    <link href="/2024/04/27/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
    <url>/2024/04/27/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<p>终于还是来了,读写分离的坑还是被我踩到了,年前接手了同事的一些代码,在上面缝缝补补,最近在自测的时候发现了一个奇怪的事儿,创建的数据推送到消息队列,本地开发环境是没有问题,到了测试环境,消息队的结构数据不正确<br>排查了一下发现是<strong>数据库读写分离</strong>的问题</p><p>本质就是,<strong>插入的数据,需要立马查询出来</strong>获取插入的主键ID,为后续业务提供关联<br>本地开发环境,连接测试数据库延时比较高(100ms往上)复现不到这个问题</p><p>如何解决这种问题网上也是一大堆</p><ol><li>在写库中读数据</li><li>等待读库后同步完数据完成后再进行同步</li></ol><p>读写分离同步流程</p><p>写库的操作</p><ol><li>修改内存数据页</li><li>记录redolog</li><li>写入binlog<ul><li>主库binlog发送到从节点</li><li>从库记录到relay log</li><li>从库从relay log读取log同步数据</li></ul></li><li>提交事务</li></ol><ul><li><p>异步复制：</p><ul><li>主库发送binlog发送到从节点,就立马提交事务响应用户</li></ul></li><li><p>半同步复制</p><ul><li>主库发送binlog发送到从节点,至少等到一个从库确认自己才提交事务然后响应用户<ul><li>并且不能解决查询从库立马获取到期望的数据,因为查询的从库可能不是响应主库的节点</li></ul></li></ul></li></ul><p>解决问题的办法:</p><ol><li>业务上实施等待,</li><li>引入缓存,插入的数据直接从缓存中获取</li><li>查询出从库是不是已经同步主库的binlog最新事务位置信息,从而可以直接在从库查询出事务变更的数据</li></ol><p>参考资料:</p><ul><li><a href="https://www.bilibili.com/video/BV1FH4y1K7rn">https://www.bilibili.com/video/BV1FH4y1K7rn</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AWS之Step Functions</title>
    <link href="/2024/03/25/blog/other/aws_step_function/"/>
    <url>/2024/03/25/blog/other/aws_step_function/</url>
    
    <content type="html"><![CDATA[<h3 id="Step-Functions">Step Functions</h3><p>官方文档:<a href="https://docs.aws.amazon.com/step-functions/latest/dg/welcome.html">https://docs.aws.amazon.com/step-functions/latest/dg/welcome.html</a></p><p>公司中的项目需要用到延时任务去处理业务上的问题,AWS自带的SQS消息延时队列最大的延时消息是15分钟,完全不能满足我们可以自定义或固定超过15分钟去处理延时任务</p><p>因此,领导安排我调研AWS Step Functions看看能不能解决这些问题</p><p>Step Functions 基于状态机和任务。在 Step Functions 中，工作流被称为状态机，它是一系列事件驱动的步骤。<br>工作流程中的每个步骤都称为状态。状态代表其他AWS服务（例如AWS Lambda）执行的工作单元。任务状态可以调用任何AWS服务或API任务</p><p>Step Functions 也提供了等待状态传入自定义时间来控制任务处理, 用来做延时任务确实符合我们的业务场景</p><p>(虽然最后没有选择使用此方案做延时任务, 因为最大的活动数量上限是10000 不能满足我们的业务量对应的需求)</p><h4 id="使用-AWS-Step-Functions-做延时任务">使用 AWS Step Functions 做延时任务</h4><p>流程步骤</p><ol><li>创建lambda函数</li><li>创建状态机添加延时任务并且绑定lambda函数</li><li>执行状态机</li></ol><p>配置本地开发环境</p><p>前置条件 安装 aws-cli, sam-cli</p><p>lambda 函数</p><ol><li>创建lambda函数<br>sam init</li><li>编译打包<br>sam build</li><li>本地运行<br>sam local start-lambda --host 0.0.0.0</li></ol><p>创建状态机环境<br>docker run --name stepfunctions -p 8083:8083 --env-file env.txt amazon/aws-stepfunctions-local</p><p>环境变量env.txt</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">AWS_DEFAULT_REGION</span>=us-east-<span class="hljs-number">1</span><br><span class="hljs-attr">AWS_ACCESS_KEY_ID</span>=<span class="hljs-number">012345678901</span><br><span class="hljs-attr">AWS_SECRET_ACCESS_KEY</span>=<span class="hljs-number">012345678901</span><br><span class="hljs-attr">LAMBDA_ENDPOINT</span>=http://<span class="hljs-number">10.0</span>.<span class="hljs-number">8.246</span>:<span class="hljs-number">3001</span>  <span class="hljs-comment"># 本地运行的lambda函数地址</span><br></code></pre></td></tr></table></figure><p>创建状态机</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> os<br><br>states = &#123;<br>    <span class="hljs-string">&quot;Comment&quot;</span>: <span class="hljs-string">&quot;example&quot;</span>,<br>    <span class="hljs-string">&quot;StartAt&quot;</span>: <span class="hljs-string">&quot;wait_until&quot;</span>,<br>    <span class="hljs-string">&quot;States&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;wait_until&quot;</span> : &#123;<br>            <span class="hljs-string">&quot;Type&quot;</span>: <span class="hljs-string">&quot;Wait&quot;</span>, <span class="hljs-comment"># 等待状态</span><br>            <span class="hljs-string">&quot;SecondsPath&quot;</span>: <span class="hljs-string">&quot;$.expirydate&quot;</span>, <span class="hljs-comment"># 从输入中获取延时时间</span><br>            <span class="hljs-string">&quot;Next&quot;</span>: <span class="hljs-string">&quot;LambdaState&quot;</span><br>        &#125;,<br>        <span class="hljs-string">&quot;LambdaState&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;Type&quot;</span>: <span class="hljs-string">&quot;Task&quot;</span>, <span class="hljs-comment"># 任务状态</span><br>            <span class="hljs-string">&quot;Resource&quot;</span>: <span class="hljs-string">&quot;arn:aws:states:::lambda:invoke&quot;</span>,<br>            <span class="hljs-string">&quot;OutputPath&quot;</span>: <span class="hljs-string">&quot;$.Payload&quot;</span>, <span class="hljs-comment"># 从lambda函数的返回值中获取输出</span><br>            <span class="hljs-string">&quot;Parameters&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;Payload.$&quot;</span>: <span class="hljs-string">&quot;$&quot;</span>, <span class="hljs-comment"># 将输入传递给lambda函数</span><br>                <span class="hljs-string">&quot;FunctionName&quot;</span>: <span class="hljs-string">&quot;arn:aws:lambda:us-east-1:function:HelloWorldFunction:$LATEST&quot;</span> <span class="hljs-comment"># lambda函数的arn</span><br>            &#125;,<br>            <span class="hljs-string">&quot;Next&quot;</span>: <span class="hljs-string">&quot;NextState&quot;</span><br>        &#125;,<br>        <span class="hljs-string">&quot;NextState&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;Type&quot;</span>: <span class="hljs-string">&quot;Pass&quot;</span>,<br>            <span class="hljs-string">&quot;End&quot;</span>: <span class="hljs-literal">True</span><br>        &#125;<br>    &#125;<br>&#125;<br><br>states_str = (json.dumps(json.dumps(states)))<br><br>cmd = <span class="hljs-string">&quot;aws stepfunctions --endpoint http://localhost:8083 create-state-machine --definition &quot;</span> + states_str + <span class="hljs-string">&quot; --name test --role-arn arn:aws:iam::123456789012:role/DummyRole&quot;</span><br><br>os.system(cmd)<br></code></pre></td></tr></table></figure><p>删除状态机<br>aws stepfunctions --endpoint-url <a href="http://localhost:8083">http://localhost:8083</a> start-execution --state-machine-arn arn:aws:states:us-east-1:123456789012:stateMachine:HelloWorld --input “{&quot;a&quot;:1}”</p><p>golang执行状态机方法并且传递参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;github.com/aws/aws-sdk-go/aws&quot;</span><br><span class="hljs-string">&quot;github.com/aws/aws-sdk-go/aws/session&quot;</span><br><span class="hljs-string">&quot;github.com/aws/aws-sdk-go/service/sfn&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 创建 AWS 会话</span><br>sess, err := session.NewSession(&amp;aws.Config&#123;<br>Region:   aws.String(<span class="hljs-string">&quot;us-east-1&quot;</span>),             <span class="hljs-comment">// 替换为 AWS 区域</span><br>Endpoint: aws.String(<span class="hljs-string">&quot;http://localhost:8083&quot;</span>), <span class="hljs-comment">// 替换为 Step Functions 本地端点</span><br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><br><span class="hljs-comment">// 创建 Step Functions 客户端</span><br>sfnClient := sfn.New(sess)<br><br><span class="hljs-comment">// 定义输入参数</span><br>input := <span class="hljs-string">`&#123;&quot;expirydate&quot;:11, &quot;a&quot;:1233333&#125;`</span><br><br><span class="hljs-comment">// 指定状态机的 ARN</span><br>stateMachineARN := <span class="hljs-string">&quot;arn:aws:states:us-east-1:123456789012:stateMachine:test&quot;</span><br><br><span class="hljs-comment">// 调用状态机</span><br>result, err := sfnClient.StartExecution(&amp;sfn.StartExecutionInput&#123;<br>Input:           &amp;input,<br>StateMachineArn: &amp;stateMachineARN,<br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><br><span class="hljs-comment">// 打印执行的 ARN</span><br>fmt.Println(<span class="hljs-string">&quot;Execution ARN:&quot;</span>, *result.ExecutionArn)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>aws</tag>
      
      <tag>Step Functions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>熬过 2023, 2023 总结</title>
    <link href="/2024/03/24/blog/article/summary_by_2023/"/>
    <url>/2024/03/24/blog/article/summary_by_2023/</url>
    
    <content type="html"><![CDATA[<h4 id="2023年">2023年</h4><p>迟到的2023年总结,是拖延症也是忙碌,导致现在才开始回想2023一年的事情,2023年对我来说是残酷的一年,也是我印象深刻的一年,这年我拥了两只喵咪,<br>换了两份工作,骑着踏板车去到了陕西韩城市,见了未来老丈,开始焦虑未来.</p><h4 id="生活">生活</h4><ul><li>见了未来老丈</li><li>又带了一只小猫回家,同时拥有了处理不完的猫毛烦恼</li><li>6月骑着我的小踏板去了韩城,距离西安不到300公里的路程,用了八个多小时,真的很值得,沿着黄河一路的风景真的美如画</li></ul><h4 id="工作">工作</h4><p>23年的工作,真是让我很难过,3月慌忙入职的公司,小组在9月团队解散,一切都有预兆可循,怪我没有擦亮眼睛<br>(面试的时候一个公司名称,发offer的时候又是另外一家,签劳动合同又是另外一家,发工资又换了一家)<br>9月,10月开始面试,沟通了89家公司,投了31分简历,面试7家,拿到4个offer</p><p>因为工作的事,我开始越来越焦虑,时不时开始思考未来的事情</p><h4 id="技术">技术</h4><ul><li>程序员三件套之记账,开发了一个微信小程序记账</li><li>用go开发了生成数据库ER图的工具</li><li><a href="https://maocat.cc/2023/03/06/blog/golang/gin_handlefunc">用反射闭包了一下 Gin 的 HandlerFunc</a></li></ul><p>2023年,我发现了我自己最大的问题<strong>粗心</strong></p><p>2023年,我给它的关键词是<strong>活着</strong>,这年没有攒下钱,也给我带来了焦虑</p><h4 id="2024目标">2024目标</h4><ul><li>学会双拼</li><li>重拾java</li><li>改变自己粗心的毛病</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>思考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vscode手册</title>
    <link href="/2023/12/01/%E5%9F%BA%E7%A1%80/vscode%E6%89%8B%E5%86%8C/"/>
    <url>/2023/12/01/%E5%9F%BA%E7%A1%80/vscode%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="目录树的层级完全铺开">目录树的层级完全铺开</h3><p><img src="/asset/%E5%9F%BA%E7%A1%80/images/dir_level.png" alt="目录树的层级完全铺开"></p><h3 id="展示隐藏的文件目录">展示隐藏的文件目录</h3><p><img src="/asset/%E5%9F%BA%E7%A1%80/images/unhide.png" alt="展示隐藏的文件目录"></p>]]></content>
    
    
    
    <tags>
      
      <tag>参考资料</tag>
      
      <tag>vscode手册</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 langchain 做一个 prompt 工程师 🙈</title>
    <link href="/2023/08/01/blog/article/langchain_prompt/"/>
    <url>/2023/08/01/blog/article/langchain_prompt/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/langchain-ai/langchain">langchain</a>是一个开发由语言模型驱动的应用程序的框架,简单来说就是将LMM打包层应用层面的封装,使普通开发者(比如我)也能开发AI相关的应用</p><p>我能想到的相关应用：</p><ol><li>聊天机器人</li><li>知识文档问答库(AI客服) <a href="https://github.com/chatchat-space/Langchain-Chatchat">Langchain-Chatchat</a></li><li>构建NLP应用程序</li><li>…</li></ol><p>如果你使用过 ChatGPT 就会发现 GPT 回答问题的时候就会多说一些前后缀相关无用的东西,使用 langchain 的 <strong>prompt template</strong> 就能非常方便的避免掉这个问题</p><p>一个示例, 使用 ExampleSelector 和 PromptTemplate 做提示返回模板</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain.llms <span class="hljs-keyword">import</span> OpenAI<br><span class="hljs-keyword">from</span> langchain.prompts.example_selector <span class="hljs-keyword">import</span> SemanticSimilarityExampleSelector<br><span class="hljs-keyword">from</span> langchain.output_parsers <span class="hljs-keyword">import</span> ResponseSchema, StructuredOutputParser<br><span class="hljs-keyword">from</span> langchain.embeddings <span class="hljs-keyword">import</span> OpenAIEmbeddings<br><span class="hljs-keyword">from</span> langchain.vectorstores <span class="hljs-keyword">import</span> FAISS<br><span class="hljs-keyword">from</span> langchain.prompts <span class="hljs-keyword">import</span> FewShotPromptTemplate, PromptTemplate<br><br>openai_api_key = <span class="hljs-string">&quot;&#123;&#123;you_openai_api_key&#125;&#125;&quot;</span><br>llm: OpenAI = OpenAI(<br>    openai_proxy=<span class="hljs-string">&quot;127.0.0.1:4780&quot;</span>, <span class="hljs-comment">## 这里是代理，你懂的</span><br>    openai_api_key=openai_api_key)<br><br>response_schemas = [<br>    ResponseSchema(name=<span class="hljs-string">&quot;user_input&quot;</span>, description=<span class="hljs-string">&quot;这是用户的输入&quot;</span>),<br>    ResponseSchema(name=<span class="hljs-string">&quot;date&quot;</span>, description=<span class="hljs-string">&quot;这是通过用户的输入得到的时间&quot;</span>)<br>]<br><br>outputParser = StructuredOutputParser.from_response_schemas(response_schemas)<br><br>template = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"></span><br><span class="hljs-string">示例输入:</span><br><span class="hljs-string">&#123;user_input&#125;</span><br><span class="hljs-string">示例输出:</span><br><span class="hljs-string">&#123;output&#125;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>example_prompt = PromptTemplate(<br>    template=template,<br>    input_variables=[<span class="hljs-string">&quot;user_input&quot;</span>, <span class="hljs-string">&quot;output&quot;</span>],<br>)<br><br>examples = [<br>    &#123;<span class="hljs-string">&quot;user_input&quot;</span>: <span class="hljs-string">&quot;今天是2023-08-01,今天吃米饭用了10元&quot;</span>,<br>     <span class="hljs-string">&quot;output&quot;</span>: <span class="hljs-string">&quot;&quot;&quot;date:2023-08-01,amount:10, user_input:昨天早上吃米饭用了10元&quot;&quot;&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;user_input&quot;</span>: <span class="hljs-string">&quot;今天是2023-08-02,昨天早上吃米饭用了10.1元&quot;</span>,<br>     <span class="hljs-string">&quot;output&quot;</span>: <span class="hljs-string">&quot;&quot;&quot;date:2023-08-01,amount:10.1, user_input:昨天早上吃米饭用了10元&quot;&quot;&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;user_input&quot;</span>: <span class="hljs-string">&quot;今天是2023-08-03,前天早上吃米饭用了11元&quot;</span>,<br>     <span class="hljs-string">&quot;output&quot;</span>: <span class="hljs-string">&quot;&quot;&quot;date:2023-08-01, amount:11, user_input:前天早上吃米饭用了11元&quot;&quot;&quot;</span>&#125;,<br>]<br><br>example_selector = SemanticSimilarityExampleSelector.from_examples(<br>    examples=examples,<br>    embeddings=OpenAIEmbeddings(openai_api_key=openai_api_key),<br>    vectorstore_cls=FAISS,<br>    k=<span class="hljs-number">3</span><br>)<br><br>similar_prompt = FewShotPromptTemplate(<br>    example_selector=example_selector,<br>    example_prompt=example_prompt,<br>    prefix=<span class="hljs-string">&quot;您将从用户那得到一段文字, 解析相关内容并且返回相关的内容&quot;</span>,<br>    suffix=<span class="hljs-string">&quot;用户输入:&#123;user_input&#125;\n解析结果:&quot;</span>,<br>    input_variables=[<span class="hljs-string">&quot;user_input&quot;</span>],<br>)<br><br><span class="hljs-built_in">print</span>(similar_prompt.<span class="hljs-built_in">format</span>(user_input=<span class="hljs-string">&quot;今天是2023-08-03,今天吃米饭用了10元&quot;</span>))<br><br><span class="hljs-built_in">print</span>(llm(similar_prompt.<span class="hljs-built_in">format</span>(user_input=<span class="hljs-string">&quot;今天是2023-08-01,前天吃米饭用了3.3元&quot;</span>)))<br><br><span class="hljs-comment">## date:2023-07-30, amount:3.3, user_input:前天吃米饭用了3.3元</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>langchain</tag>
      
      <tag>prompt</tag>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么我们放弃了基于 GraphQL 的CQRS架构</title>
    <link href="/2023/07/13/blog/article/why_donot_use_graphql/"/>
    <url>/2023/07/13/blog/article/why_donot_use_graphql/</url>
    
    <content type="html"><![CDATA[<p>当接手项目后，一开始 Hasura GraphQL 确实为我们搭建数据表和进行连表查询提供了便利。在项目初期，它似乎非常有吸引力，能够迅速获得所需的基础数据，查询接口的编写速度快，前端可以无缝使用跨库跨表查询。</p><p>然而，随着项目的进一步开发，一些细节问题逐渐浮出水面，我们发现 GraphQL 并不适合我们的业务场景。有时，一个查询语句可能需要花费大量时间，而系统复杂度的增加经常导致以前的接口需要重构，这增加了开发成本。这让我们不禁思考，GraphQL 是否真的能提高开发效率。在选择上变得更加困难，因为维护它通常需要更多的成本。因此，我向领导提出了放弃 GraphQL 的建议。</p><ol><li><p><strong>人员成本和学习成本</strong>：在 Hasura GraphQL 初始阶段，后端配置了基础查询语句，但前端仍需添加细节。这导致后端开发人员不断跟在前端人员后面，前端人员也需要学习 GraphQL 知识, 这使得前后端在任务开发时是紧密耦合的，本来只用定义好开发文档，就能进行并行开发了。</p></li><li><p><strong>业务复杂度</strong>：在业务开发中，通常会出现一些特殊的需求，这些需求不仅预料之外，而且超出了常规范围，需要特殊条件查询和字段过滤。例如，基于树状数据表进行特殊处理查询，这在 GraphQL 中很难实现，因为 GraphQL 是基于数据表而不是业务的。这可能需要在数据库层面编写大量函数来解决，进一步增加了系统的复杂性。并且业务不是一成不变的, GraphQL 配置中的 Schema 的维护又得单独维护</p></li><li><p><strong>数据权限控制</strong>：Hasura GraphQL 的权限配置繁琐，开发人员需要大量时间来设置权限。随着系统角色的增加，配置变得更加复杂。如果没有正确配置数据的权限，当前用户对这些数据的查询将无法看到。虽然可以通过视图来解决权限问题，但引入视图会带来对其的维护成本。</p></li><li><p><strong>项目发布问题</strong>：在正常系统中，只需在发布前修改或添加数据库数据表，项目就可以轻松上线。然而，在 Hasura GraphQL 中，需要在发布前修改数据库数据表，并相应地更新 Hasura GraphQL 配置，这使得发布过程变得复杂且容易出错，尤其在多个系统环境下。</p></li><li><p><strong>缓存</strong>：使用 Hasura GraphQL 意味着失去了对缓存的控制权，这可能会对性能产生负面影响。</p></li><li><p><strong>日志</strong>：在 GraphQL 中，与后端日志的精细连接变得困难，这会导致排查数据问题变得复杂。</p></li><li><p><strong>聚合数据</strong>：在现代系统中，通常需要处理一些与业务智能 (BI) 相关的内容。在 GraphQL 中，聚合数据变得非常复杂，需要在数据库层面编写大量函数来解决。业务可能会不断变化，因此不希望每次都修改数据库层面的代码，但维护多一套的成本可能不可接受。</p></li></ol><p>综上所述，项目中All In GraphQL，有时候并不能提高开发效率，反而会增加开发成本，维护成本。这也并不意味着 GraphQL 不适合所有项目，它仍然是一个很好的工具，可以在某些场景下提高开发效率。在选择 GraphQL 时，需要考虑项目的复杂度，以及是否有必要使用 GraphQL。</p>]]></content>
    
    
    
    <tags>
      
      <tag>思考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>避坑之 grpc metadata 不能存入非 ASCll 字符</title>
    <link href="/2023/07/06/blog/article/rpc_meta_header/"/>
    <url>/2023/07/06/blog/article/rpc_meta_header/</url>
    
    <content type="html"><![CDATA[<h3 id="grpc-metadata-不能存入非-ASCll-字符">grpc metadata 不能存入非 ASCll 字符</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">rpc <span class="hljs-keyword">error</span>: code = Internal desc = header key <span class="hljs-string">&quot;user_name&quot;</span> <span class="hljs-keyword">contains</span> value <span class="hljs-keyword">with</span> non-printable ASCll <span class="hljs-built_in">characters</span><br></code></pre></td></tr></table></figure><p>项目中进行 rpc 调用的时候出现这个问题,问题很容易追踪, 就是在<br>metadata.AppendToOutgoingContext 里user_name对应的value存入中文</p><p>在 grpc 源码中就能找到对应的限制, 如果非要进行中文传输,可以添加后缀<code>-bin</code>(例如:<code>user_name-bin</code>), 表示对应的数据通过二进制数据进行编码解码传输</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">google.golang.org/grpc/internal/metadata/metadata.<span class="hljs-keyword">go</span>:<span class="hljs-number">90</span><br><span class="hljs-comment">// hasNotPrintable return true if msg contains any characters which are not in %x20-%x7E</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasNotPrintable</span><span class="hljs-params">(msg <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-comment">// for i that saving a conversion if not using for range</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(msg); i++ &#123;<br><span class="hljs-keyword">if</span> msg[i] &lt; <span class="hljs-number">0x20</span> || msg[i] &gt; <span class="hljs-number">0x7E</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>gRPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一次重复支付引发的思考</title>
    <link href="/2023/06/13/blog/article/the_pay/"/>
    <url>/2023/06/13/blog/article/the_pay/</url>
    
    <content type="html"><![CDATA[<p>如何避免订单重复提交和重复支付, 在网上一些文章视频都很好的讲出怎么避免此类问题</p><p>然而重复支付真正发生在自己身上, 却还是焦头烂额</p><hr><h2 id="复盘">复盘</h2><ol><li><strong><em>6月10日13点22分</em></strong>, 业务方反馈支付系统对人员自动打款没有到账, 让排查问题</li><li><strong><em>13点36分</em></strong>, 我反馈支付服务压根没有收到支付请求, 产品让业务服务手动把支付状态改为支付失败, 这样可以在页面上手动支付</li><li><strong><em>13点36分-13点44分</em></strong>, 业务服务修改支付状态后, 重新手动支付, 我查看日志中发现触发支付接口, 但是在<strong>流水中生成了对同一人的两笔支付流水</strong>, 我反馈大概触发了<strong>重复支付</strong></li></ol><p>三方支付api已经返回处理中, 我们只能眼睁睁的看着钱打进人员手上,还好领导在人员跟前,及时处理冲红了这笔流水</p><hr><h2 id="排查">排查</h2><p>追踪了一下业务, 业务系统每30分钟会触发一次支付 ( 付款方账户里的钱可能不足, 所以需要每30分钟校验账户钱是否满足支付 ) , 恰恰在<strong>定时任务load进支付任务后,页面又触发了手动支付</strong>, 导致打款重复</p><hr><h2 id="防线">防线</h2><h3 id="防线之前">防线之前</h3><p><strong>日志</strong>的重要性这时候就体现出来了, 好在日志是我入职以来一直在推进的流程, 有日志就能快速定位复盘问题</p><h3 id="前端防抖">前端防抖</h3><p>防本不防根</p><h3 id="令牌机制">令牌机制</h3><p>支付系统下发令牌, 只有在令牌有效期内才能支付, 令牌只能使用一次, 令牌无效返回错误</p><h3 id="订单号处理">订单号处理</h3><p>业务系统生成的单号, 支付系统针对单号做幂等处理, 重复提交会返回错误</p><h3 id="预支付状态">预支付状态</h3><p>支付中可能需要撤回相应的支付 ( 避免眼睁睁~~~ ), 因此可以设计处于<strong>3分钟</strong>(在风控中可逐步提高)的预支付状态, 系统扫描预支付状态的订单, 如果超过<strong>3分钟</strong>还处于预支付状态, 就对其进行支付</p>]]></content>
    
    
    
    <tags>
      
      <tag>思考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Bitwarden_RS 构建属于自己的密码管理器</title>
    <link href="/2023/05/13/blog/article/the_bitwarden/"/>
    <url>/2023/05/13/blog/article/the_bitwarden/</url>
    
    <content type="html"><![CDATA[<h3 id="痛痛痛">痛痛痛</h3><p>生活在互联网上, 账号密码的记录真的是让人头疼的问题, 各种网站应用的登录,不同的账号密码规则,有时候还有同一个网站应用开了多套账号</p><p>因此,密码管理器顺势而出,只用记住一个主密码,就可以管理所有的账号密码</p><p>市面上的密码管理器有很多,非常有名的有1Password, LastPass, Dashlane, Bitwarden等等,V站上每个月都有讨论这方面的帖子</p><p>废话多说, 分享一下个人搭建的Bitwarden_RS使用体验</p><h3 id="Bitwarden-RS">Bitwarden_RS</h3><p>一个docker-compose.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">vaultwarden:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">vaultwarden/server:latest</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">WEBSOCKET_ENABLED=true</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">SIGNUPS_ALLOWED=true</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ENABLE_PASSWORD_HINTS=true</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">SHOW_PASSWORD_HINT=true</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">PASSWORD_HINTS_REQUIRED=false</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;13123:80&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3012:3012&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">~/1ps/data:/data</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br></code></pre></td></tr></table></figure><p>SIGNUPS_ALLOWED=true 开启注册</p><p>ENABLE_PASSWORD_HINTS=true 开启密码提示</p><p>SHOW_PASSWORD_HINT=true 显示密码提示</p><p>服务器搭建完成在使用nginx反代, 加上域名, 套个https, 完美</p><p><strong>主页</strong><br><img src="/asset/blog/article/images/image.png" alt=""><br><strong>注册</strong><br><img src="/asset/blog/article/images/image1.png" alt=""></p><p><strong>内容页</strong><br><img src="/asset/blog/article/images/image4.png" alt=""></p><p>应用/插件下载地址</p><p><a href="https://bitwarden.com/download/">https://bitwarden.com/download/</a></p><p><strong>Chrome插件</strong><br><img src="/asset/blog/article/images/image2.png" alt=""></p><p><strong>先写自建服务地址</strong><br><img src="/asset/blog/article/images/image3.png" alt=""></p><p>接下来在常用网站登录就会提示保存密码了</p><p>强烈开启密码填充</p><p>这样下次进来登录页面就会自动填充账号密码了,非常滴方便</p>]]></content>
    
    
    
    <tags>
      
      <tag>分享发现</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;逆向学习小记之request headers藏了加密信息&gt;axios拦截器之axios.interceptors.request.use</title>
    <link href="/2023/04/06/blog/python/spider__interceptors_request_use/"/>
    <url>/2023/04/06/blog/python/spider__interceptors_request_use/</url>
    
    <content type="html"><![CDATA[<p>网站</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">btoa</span>(<span class="hljs-string">&#x27;aHR0cHM6Ly95Z3AuZ2R6d2Z3Lmdvdi5jbi8jLzQ0MDYwMC9qeWdn&#x27;</span>)<br></code></pre></td></tr></table></figure><p>网站中所有请求都带了</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">X-Dgi-Req-App</span><span class="hljs-punctuation">: </span>xxxx<br><span class="hljs-attribute">X-Dgi-Req-Nonce</span><span class="hljs-punctuation">: </span>xxx<br><span class="hljs-attribute">X-Dgi-Req-Signature</span><span class="hljs-punctuation">: </span>xxxxxxx<br><span class="hljs-attribute">X-Dgi-Req-Timestamp</span><span class="hljs-punctuation">: </span>xxx<br><br></code></pre></td></tr></table></figure><p>错误的签名或者没有签名都会出现错误</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;errcode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">91000</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;errmsg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;参数签名异常&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>看看网站js源码,使用 axios 发起响应请求</p><p>发送请求前都会设置 header 添加加密信息, 在Source里搜一下 interceptors.request.use</p><p>得到了</p><p><img src="/asset/blog/python/images/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230331173735.png" alt="123"></p><p><code>function u(r)</code> 就是设置 header 添加加密参数的方法</p><p>基本上追一下就能拿取到想用的东西了</p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gorm 中使用 Postgres 的 json</title>
    <link href="/2023/03/06/blog/article/gorm_pgsql_json/"/>
    <url>/2023/03/06/blog/article/gorm_pgsql_json/</url>
    
    <content type="html"><![CDATA[<p>官方json文档 <a href="https://www.postgresql.org/docs/12/functions-json.html">https://www.postgresql.org/docs/12/functions-json.html</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;database/sql/driver&quot;</span><br><span class="hljs-string">&quot;encoding/json&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;gorm.io/driver/postgres&quot;</span><br><span class="hljs-string">&quot;gorm.io/gorm&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> db *gorm.DB<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">initPgsql</span><span class="hljs-params">()</span></span> &#123;<br>dsn := <span class="hljs-string">&quot;host=192.168.163.121 user=postgres password=postgres dbname=test port=5432 sslmode=disable TimeZone=Asia/Shanghai&quot;</span><br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>db, err = gorm.Open(postgres.Open(dsn), &amp;gorm.Config&#123;&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// User 用户</span><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>gorm.Model<br>Name    <span class="hljs-type">string</span><br>Profile Profile <span class="hljs-string">`gorm:&quot;type:json&quot; json:&quot;profile&quot;`</span><br>&#125;<br><br><span class="hljs-comment">// Profile 个人信息</span><br><span class="hljs-keyword">type</span> Profile <span class="hljs-keyword">struct</span> &#123;<br>Email   <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;email&quot;`</span><br>PhoneNo <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;phoneNo&quot;`</span><br>&#125;<br><br><span class="hljs-comment">// Value 实现方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Profile)</span></span> Value() (driver.Value, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> json.Marshal(p)<br>&#125;<br><br><span class="hljs-comment">// Scan 实现方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Profile)</span></span> Scan(input <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> json.Unmarshal(input.([]<span class="hljs-type">byte</span>), p)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>initPgsql()<br>err := db.AutoMigrate(&amp;User&#123;&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>u := User&#123;<br>Name: <span class="hljs-string">&quot;maocat&quot;</span>,<br>Profile: Profile&#123;<br>Email:   <span class="hljs-string">&quot;maocatooo@gmail.com&quot;</span>,<br>PhoneNo: <span class="hljs-string">&quot;18888888888&quot;</span>,<br>&#125;,<br>&#125;<br>db.Save(&amp;u)<br><br>u.Profile.PhoneNo = <span class="hljs-string">&quot;13666666666&quot;</span><br>db.Save(&amp;u)<br><br><span class="hljs-keyword">var</span> u1 User<br><br>db.Debug().<br>Where(gorm.Expr(<span class="hljs-string">&quot;profile-&gt;&gt;&#x27;email&#x27; = ?&quot;</span>, <span class="hljs-string">&quot;maocatooo@gmail.com&quot;</span>)).<br>First(&amp;u1)<br>fmt.Println(u1.Name)<br>fmt.Println(u1.Profile)<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>Gorm</tag>
      
      <tag>Postgres</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用反射闭包了一下 Gin 的 HandlerFunc, 我终于可以开开心心的写单元测试了</title>
    <link href="/2023/03/06/blog/golang/gin_handlefunc/"/>
    <url>/2023/03/06/blog/golang/gin_handlefunc/</url>
    
    <content type="html"><![CDATA[<h3 id="center-用反射闭包了一下-Gin-的-HandlerFunc-我终于可以开开心心的写单元测试了-center"><center> 用反射闭包了一下 Gin 的 HandlerFunc, 我终于可以开开心心的写单元测试了 </center></h3><p>上家公司是用 go-micro 写 rpc, 现在跑过来写 gin, 写单元测试构造用例可太麻烦了</p><p>用反射封装了一下，我又回到当初写微服务的快乐了</p><p>没有破坏路由也没有破坏中间件，就加了 req 和 resp 的反射封装</p><p>基佬链接: <a href="https://github.com/maocatooo/thin/tree/main/gin_handler">https://github.com/maocatooo/thin/tree/main/gin_handler</a></p><p>求个 star</p><p>废话多说，上个例子</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">go</span> <span class="hljs-built_in">get</span> -<span class="hljs-keyword">u</span> github.<span class="hljs-keyword">com</span>/maocatooo/thin<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br><span class="hljs-string">&quot;github.com/maocatooo/thin/gin_handler&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Req <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Query <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span> <span class="hljs-string">`form:&quot;name&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Resp <span class="hljs-keyword">struct</span> &#123;<br>Code    <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;code&quot;`</span><br>Message <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;message&quot;`</span><br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">GET http://127.0.0.1:8080/ping?name=123</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Ping</span><span class="hljs-params">(ctx *gin.Context, req *Query, rsp *Resp)</span></span> <span class="hljs-type">error</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Ping req: %+v \n&quot;</span>, *req)<br><span class="hljs-keyword">if</span> req.Name == <span class="hljs-string">&quot;123&quot;</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;err 123&quot;</span>)<br>&#125;<br>rsp.Code = <span class="hljs-number">200</span><br>rsp.Message = req.Name<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-keyword">type</span> A <span class="hljs-keyword">struct</span> &#123;<br>a <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">POST http://127.0.0.1:8080/pong</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">&quot;name&quot;:&quot;456&quot;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a A)</span></span> Pong(ctx *gin.Context, req *Req, rsp *Resp) <span class="hljs-type">error</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Pong req: %+v \n&quot;</span>, *req)<br><span class="hljs-keyword">if</span> req.Name == <span class="hljs-string">&quot;123&quot;</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;123&quot;</span>)<br>&#125;<br>rsp.Code = <span class="hljs-number">200</span><br>rsp.Message = req.Name<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.Default()<br>r.GET(<span class="hljs-string">&quot;/ping&quot;</span>, gin_handler.Query(Ping))<br>r.POST(<span class="hljs-string">&quot;/pong&quot;</span>, gin_handler.JSON(A&#123;a: <span class="hljs-string">&quot;a123&quot;</span>&#125;.Pong))<br>_ = r.Run()<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>Gin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>腾讯一面经</title>
    <link href="/2023/02/27/%E9%9D%A2%E7%BB%8F/%E9%9D%A2%E7%BB%8F/"/>
    <url>/2023/02/27/%E9%9D%A2%E7%BB%8F/%E9%9D%A2%E7%BB%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="面经">面经</h3><p>腾讯社招一面</p><ul><li>tpc和udp区别</li><li>tcp如何保证可靠传输</li><li>三次握手四次挥手</li><li>四次挥手</li><li>TIME_WAIT 为什么要等待2MSL</li><li>Redis 为什么这么快 (多个情况)</li><li>Redis 热key</li><li>Redis 和 MongoDB区别</li><li>MySQL 数据库SQL执行流程</li><li>MySQL 聚簇索引和非聚簇索引 区别</li><li>MySQL 回表</li><li>MySQL 索引失效的情况</li><li>负责服务的QPS</li><li>建立索引后, 如何优化SQL</li><li>一个亿的用户信息表如何分库分表</li><li>Kafka 重平衡</li><li>Golang GMP</li><li>Golang STW时机</li><li>Golang 项目用遇到内存变大情况，如何调试</li><li>Golang 逃逸分析 (多个情况)</li><li>20分钟算法（两个链表相加 <a href="https://leetcode.cn/problems/lMSNwu/%EF%BC%89">https://leetcode.cn/problems/lMSNwu/）</a></li></ul><p>面试官评价，基础不好，中间件底层原理理解不够深入</p>]]></content>
    
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>再见 2022, 2022 总结</title>
    <link href="/2023/02/01/blog/article/summary_by_2022/"/>
    <url>/2023/02/01/blog/article/summary_by_2022/</url>
    
    <content type="html"><![CDATA[<h4 id="2022年">2022年</h4><p>2022年, 因为疫情一月被封到过年,中间断断续续也是因为疫情被封在家里几次,12月放开也是迅速的阳了,因为公司是内网开发,且不能远程办公,导致被封在家的时间只能从周内晚上、周末来补,也是让我真正体会到了什么是996</p><p>2022年9月老板意外去世, 12月老板娘深夜突然搬空公司机房, 导致顺利失业</p><h4 id="工作">工作</h4><ol><li>拿到了2021年公司优秀员工之一, 算是对2021的交代</li><li>完善了公司 Golang 端 Core, Plugin 代码库, 封装了很多业务功能, 框架库</li><li>着手开发了简易版基于GitLab Api的DevOps系统, 用来快速发布版本</li></ol><p>待完善:<br>业务上没有及时多沟通问题, 导致部分功能多次返工,</p><h4 id="技术">技术</h4><ol><li>利用疫情封在家的时间学习了K8S基础,<a href="http://xn--K3Smaocat-pb6nnd28d7dn36ajvz2w0a23e260j93wb5qmi77esqua.cc">并且在良心云上用K3S镜像部署了maocat.cc</a></li><li>入门了Kafka, 也是先用上, 再深入</li><li>打算开源属于自己的 Golang tool package</li></ol><p>之前套路云没有续费,导致自建的blog没有备份数据,心痛,于是暂时使用gitbook来写blog,顺便记一些笔记</p><p>因为全年都在996, 公司也是内网开发, 导致没有太多时间去学习、接触技术(都是借口/dog)</p><h4 id="生活">生活</h4><ol><li>终于领养了一只猫咪(我也是一个有爱心的男人了)</li><li>拿到摩托车驾照</li><li>厨艺大幅度增长, 已经可以自己做面食了</li></ol><p>2022年注定寒冬, 希望新的一年能事事顺利</p>]]></content>
    
    
    
    <tags>
      
      <tag>思考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 内存管理</title>
    <link href="/2023/01/07/golang/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2023/01/07/golang/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="堆内存">堆内存</h2><p>arena(64MB) -&gt; 8192 page(8KB)</p><p>span -&gt; N page(一个span包含多个page)-&gt; M 内存块(一个span等分M个内存块)</p><p>Go 语言的内存管理模块中一共包含 67 种跨度类<br>spanclass1 - 8B<br>…<br>spanclass67 - 32KB</p><p>spanclass 0 表示大于32KB的大块内存</p><ul><li>微对象 (0, 16B) — 先使用微型分配器，再依次尝试线程缓存、中心缓存和堆分配内存；</li><li>小对象 [16B, 32KB] — 依次尝试使用线程缓存、中心缓存和堆分配内存；</li><li>大对象 (32KB, +∞) — 直接在堆上分配内存</li></ul><h3 id="堆栈内存">堆栈内存</h3><p>程序中的数据和变量都会被分配到程序所在的虚拟内存中, 内存空间包含两个重要区域：栈区（Stack）和堆区（Heap）。</p><p>栈的存取速度比堆要快, 但是缺乏灵活性, 栈中数据大小和生命周期是确定的定的, 函数调用的参数、返回值以及局部变量大都会被分配到栈上, 这部分内存会由编译器进行管理</p><p>不同编程语言使用不同的方法管理堆区的内存, C++ 等编程语言会由工程师主动申请和释放内存, Go 以及 Java 等编程语言会由工程师和编译器共同管理, 堆中的对象由内存分配器分配并由垃圾收集器回收, 缺点是内存分配管理会占用资源, 速度慢, 而且会出现内存碎片和（堆）内存溢出</p><p>堆上所有的对象都会通过调用 runtime.newobject 函数分配内存, 该函数会调用</p><h3 id="逃逸分析">逃逸分析</h3><p>在编译器优化中, 逃逸分析是用来决定指针动态作用域的方法。Go 语言的编译器使用逃逸分析决定哪些变量应该在栈上分配, 哪些变量应该在堆上分配, 其中包括使用 new、make 和字面量等方法隐式分配的内存, Go 语言的逃逸分析遵循以下两个不变性：</p><ul><li>指向栈对象的指针不能存在于堆中；</li><li>指向栈对象的指针不能在栈对象回收后存活；</li></ul><p>变量是否会被函数外部引用决定了堆栈内存的分配, 如果外部没有引用, 那么对象优先创建在栈内存, 如果外部确定了引用, 那么对象必定会创建在堆内存, 编译器并不能确定是否会被外部引用, 那么也会创建在堆内存中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">go build -gcflags &quot;-m -l&quot; common.go<br>go tool compile -S common.go<br></code></pre></td></tr></table></figure><h4 id="场景">场景</h4><ol><li><p>函数返回局部变量的指针</p></li><li><p>栈空间不足</p></li><li><p>变量大小不确定, 如创建 切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">a := <span class="hljs-number">10</span><br>l := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, a)<br></code></pre></td></tr></table></figure></li><li><p>空接口类型，函数参数是空接口类型</p></li><li><p>闭包函数</p></li></ol><h3 id="垃圾回收">垃圾回收</h3><h1>STW</h1><p>随着用户程序申请越来越多的内存, 系统中的垃圾也逐渐增多；当程序的内存占用达到一定阈值时, 整个应用程序就会全部暂停, 垃圾收集器会扫描已经分配的所有对象并回收不再使用的内存空间, 当这个过程结束后, 用户程序才可以继续执行, 出现了暂停程序（Stop the world, STW）问题</p><h4 id="标记清除">标记清除</h4><p>标记清除（Mark-Sweep）算法是最常见的垃圾收集算法, 标记清除收集器是跟踪式垃圾收集器, 其执行过程可以分成标记（Mark）和清除（Sweep）两个阶段：</p><ul><li>标记阶段 — 从根对象出发查找并标记堆中所有存活的对象；</li><li>清除阶段 — 遍历堆中的全部对象, 回收未被标记的垃圾对象并将回收的内存加入空闲链表</li></ul><h3 id="三色抽象">三色抽象</h3><p>为了解决原始标记清除算法带来的长时间STW, 多数现代的追踪式垃圾收集器都会实现三色标记算法的变种以缩短 STW 的时间。三色标记算法将程序中的对象分成白色、黑色和灰色三类4：</p><ul><li>白色对象 — 潜在的垃圾, 其内存可能会被垃圾收集器回收；</li><li>黑色对象 — 活跃的对象, 包括不存在任何引用外部指针的对象以及从根对象可达的对象；</li><li>灰色对象 — 活跃的对象, 因为存在指向白色对象的外部指针, 垃圾收集器会扫描这些对象的子对象；</li></ul><p>在垃圾收集器开始工作时, 程序中不存在任何的黑色对象, 垃圾收集的根对象会被标记成灰色, 垃圾收集器只会从灰色对象集合中取出对象开始扫描, 当灰色集合中不存在任何对象时, 标记阶段就会结束</p><p>三色标记垃圾收集器的工作原理很简单, 归纳成以下几个步骤：</p><ul><li>从灰色对象的集合中选择一个灰色对象并将其标记成黑色；</li><li>将黑色对象指向的所有对象都标记成灰色, 保证该对象和被该对象引用的对象都不会被回收；</li><li>重复上述两个步骤直到对象图中不存在灰色对象；</li></ul><p><img src="/asset/golang/images/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4.png" alt="sanse"></p><p><img src="/asset/golang/images/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A42.png" alt="sanse"><br>因为用户程序可能在标记执行的过程中修改对象的指针, 所以三色标记清除算法本身是不可以并发或者增量执行的, 它仍然需要 STW, 在如下所示的三色标记过程中, 用户程序建立了从 A 对象到 D 对象的引用, 但是因为程序中已经不存在灰色对象了, 所以 D 对象会被垃圾收集器错误地回收</p><p><img src="/asset/golang/images/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A43.png" alt="sanse"><br>本来不应该被回收的对象却被回收了, 这在内存管理中是非常严重的错误, 我们将这种错误称为悬挂指针, 即指针没有指向特定类型的合法对象, 影响了内存的安全性, 想要并发或者增量地标记对象还是需要使用屏障技术</p><h3 id="屏障技术">屏障技术</h3><p>内存屏障技术是一种屏障指令, 它可以让 CPU 或者编译器在执行内存相关操作时遵循特定的约束, 目前多数的现代处理器都会乱序执行指令以最大化性能, 但是该技术能够保证内存操作的顺序性, 在内存屏障前执行的操作一定会先于内存屏障后执行的操作</p><p>想要在并发或者增量的标记算法中保证正确性, 我们需要达成以下两种三色不变性（Tri-color invariant）中的一种：</p><ul><li>强三色不变性 — 黑色对象不会指向白色对象, 只会指向灰色对象或者黑色对象；</li><li>弱三色不变性 — 黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径</li></ul><h4 id="插入写屏障">插入写屏障</h4><p><img src="/asset/golang/images/%E6%8F%92%E5%85%A5%E5%86%99%E5%B1%8F%E9%9A%9C.png" alt="插入写屏障"></p><p>插入写屏障, 在一个垃圾收集器和用户程序交替运行的场景中会出现如上图所示的标记过程：</p><ul><li>垃圾收集器将根对象指向 A 对象标记成黑色并将 A 对象指向的对象 B 标记成灰色；</li><li>用户程序修改 A 对象的指针, 将原本指向 B 对象的指针指向 C 对象, 这时触发写屏障将 C 对象标记成灰色；</li><li>垃圾收集器依次遍历程序中的其他灰色对象, 将它们分别标记成黑色</li></ul><p>插入写屏障是一种相对保守的屏障技术, 它会将有存活可能的对象都标记成灰色以满足强三色不变性。在如上所示的垃圾收集过程中, 实际上不再存活的 B 对象最后没有被回收；而如果我们在第二和第三步之间将指向 C 对象的指针改回指向 B, 垃圾收集器仍然认为 C 对象是存活的, 这些被错误标记的垃圾对象只有在下一个循环才会被回收。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">writePointer(slot, ptr)<br>    shade(*slot)<br>    *slot = ptr<br></code></pre></td></tr></table></figure><p>插入式写屏障虽然实现非常简单并且也能保证强三色不变性, 但是它也有明显的缺点。因为栈上的对象在垃圾收集中也会被认为是根对象, 所以为了保证内存的安全, Dijkstra 必须为栈上的对象增加写屏障或者在标记阶段完成重新对栈上的对象进行扫描, 这两种方法各有各的缺点, 前者会大幅度增加写入指针的额外开销, 后者重新扫描栈对象时需要暂停程序, 垃圾收集算法的设计者需要在这两者之前做出权衡</p><h4 id="删除写屏障">删除写屏障</h4><p><img src="/asset/golang/images/%E5%88%A0%E9%99%A4%E5%86%99%E5%B1%8F%E9%9A%9C.png" alt="删除写屏障"></p><p>假设我们在应用程序中使用 Yuasa 提出的删除写屏障, 在一个垃圾收集器和用户程序交替运行的场景中会出现如上图所示的标记过程：</p><p>垃圾收集器将根对象指向 A 对象标记成黑色并将 A 对象指向的对象 B 标记成灰色；</p><ul><li>用户程序将 A 对象原本指向 B 的指针指向 C, 触发删除写屏障, 但是因为 B 对象已经是灰色的, 所以不做改变；</li><li>用户程序将 B 对象原本指向 C 的指针删除, 触发删除写屏障, 白色的 C 对象被涂成灰色；</li><li>垃圾收集器依次遍历程序中的其他灰色对象, 将它们分别标记成黑色</li></ul><p>因为增量和并发两种方式都可以与用户程序交替运行, 所以我们需要使用屏障技术保证垃圾收集的正确性；与此同时, 应用程序也不能等到内存溢出时触发垃圾收集, 因为当内存不足时, 应用程序已经无法分配内存, 这与直接暂停程序没有什么区别, 增量和并发的垃圾收集需要提前触发并在内存不足前完成整个循环, 避免程序的长时间暂停</p><h4 id="混合写屏障">混合写屏障</h4><p>在 Go 语言 v1.7 版本之前, 运行时会使用 Dijkstra 插入写屏障保证强三色不变性, 但是运行时并没有在所有的垃圾收集根对象上开启插入写屏障。因为应用程序可能包含成百上千的 Goroutine, 而垃圾收集的根对象一般包括全局变量和栈对象, 如果运行时需要在几百个 Goroutine 的栈上都开启写屏障, 会带来巨大的额外开销, 所以 Go 团队在实现上选择了在标记阶段完成时暂停程序、将所有栈对象标记为灰色并重新扫描, 在活跃 Goroutine 非常多的程序中, 重新扫描的过程需要占用 10 ~ 100ms 的时间。</p><p>Go 语言在 v1.8 组合 Dijkstra 插入写屏障和 Yuasa 删除写屏障构成了如下所示的混合写屏障, 该写屏障会将被覆盖的对象标记成灰色并在当前栈没有扫描时将新对象也标记成灰色</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">writePointer(slot, ptr):<br>    shade(*slot)<br>    <span class="hljs-keyword">if</span> current stack is grey:<br>        shade(ptr)<br>    *slot = ptr<br></code></pre></td></tr></table></figure><p>为了移除栈的重扫描过程, 除了引入混合写屏障之外, 在垃圾收集的标记阶段, 我们还需要将创建的所有新对象都标记成黑色, 防止新分配的栈内存和堆内存中的对象被错误地回收, 因为栈内存在标记阶段最终都会变为黑色, 所以不再需要重新扫描栈空间</p><h3 id="gc触发时机">gc触发时机</h3><ul><li>内存分配量达到阈值:— 堆内存的分配达到达控制器计算的触发堆大小；</li><li>定时触发：— 如果一定时间内没有触发, 就会触发新的循环, 该出发条件由 runtime.forcegcperiod 变量控制, 默认为 2 分钟；</li><li>手动触发：<strong>runtime.GC</strong> 用户程序手动触发垃圾收集</li></ul><h4 id="Go-GC如何工作">Go GC如何工作</h4><p>Golang GC的大部分处理是和用户代码并行的, GC期间用户代码可能会改变某些对象的状态, 如何实现并行呢？</p><ol><li><p>Mark：</p><p>Mark Prepare：初始化GC任务, 包括开启写屏障（write barrier）和辅助GC（mutator assist）, 统计root对象的任务数量等, 这个过程需要STW。</p><p>GC Drains：扫描所有root对象, 包括全局指针和goroutine（G）栈上的指针, 扫描对于G栈时需停止该G, 将其加入标记队列（灰色队列）, 并循环处理灰色队列的对象, 直到灰色对象为空, 该过程后台并行执行。</p></li><li><p>Mark Termination：完成标记工作, 需要重新扫描全局指针和栈, 因为Mark和用户程序是并行的, 所以在该过程中可能会有新的对象分配和指针赋值, 这个时候就需要通过写屏障记录下来, 重新扫描再检查一下。这个过程也是会STW的。</p></li><li><p>Sweep：按照标记结果回收所有的白色对象, 该过程后台并行执行。</p></li><li><p>Sweep Termination：对未扫描的范围进行扫描, 只有上一轮GC的清扫工作完成才可以开始新的一轮GC。</p></li></ol><h4 id="辅助GC">辅助GC</h4><p>Golang实际是把用户代码–&gt;大段GC—&gt;用户代码分散为用户代码—&gt;小段GC—&gt;用户代码—&gt;小段GC—&gt;用户代码,</p><p>如果GC速度跟不上分配速度, 会把用户逻辑暂停, 同时会把用户线程抢占过来加入到垃圾回收里面加快垃圾回收速度。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 一些题目</title>
    <link href="/2023/01/06/golang/%E4%B8%80%E4%BA%9B%E9%A2%98%E7%9B%AE/"/>
    <url>/2023/01/06/golang/%E4%B8%80%E4%BA%9B%E9%A2%98%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="golang中分为值类型和引用类型">golang中分为值类型和引用类型</h3><ul><li>值类型分别有：int系列、float系列、bool、string、数组和结构体</li><li>引用类型有：指针、slice切片、管道channel、接口interface、map、函数等</li><li>值类型的特点是：变量直接存储值, 内存通常在栈中分配</li><li>引用类型的特点是：变量存储的是一个地址, 这个地址对应的空间里才是真正存储的值, 内存通常在堆中分配</li></ul><h3 id="数组和切片的区别">数组和切片的区别</h3><p>数组是定长的, 数组是值类型<br>切片是不定长的, 是引用类型, 且需要通过make来初始化, 否则是nil</p><h3 id="make和new">make和new</h3><ul><li>make 的作用是初始化内置的数据结构, 也就是我们在前面提到的切片、哈希表和 Channel</li><li>new 的作用是根据传入的类型分配一片内存空间并返回指向这片内存空间的指针</li></ul><h3 id="方法值接收者和指针接收者的区别">方法值接收者和指针接收者的区别</h3><ul><li>如果方法的接受者是指针类型，无论调用者是对象还是对象指针, 修改的都是对象本身，会影响调用者;</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(o *obj)</span></span> method()<br></code></pre></td></tr></table></figure><ul><li>如果方法的接受者是指针类型，无论调用者是对象还是对象指针, 修改的都是对象本身，会影响调用者;</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(o obj)</span></span> method()<br></code></pre></td></tr></table></figure><ul><li>使用指针类型的理由<ul><li>希望修改调用者的值</li><li>避免每次调用方法时复制该值，在值的类型为大型结构体时，使用指针会更加高效</li></ul></li></ul><h3 id="Go函数返回局部变量的指针是否安全">Go函数返回局部变量的指针是否安全</h3><p>函数局部变量的指针返回，go编译器会进行逃逸分析，如果局部变量的作用域超出该函数，则不会将内存分配在栈上，而是分配在堆上</p><h3 id="slice扩容机制">slice扩容机制</h3><ul><li>如果当前切片的长度小于 1024 就会将容量翻倍；</li><li>如果当前切片的长度大于 1024 就会每次增加 25% 的容量, 直到新容量大于期望容量；</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang slice</title>
    <link href="/2023/01/05/golang/slice/"/>
    <url>/2023/01/05/golang/slice/</url>
    
    <content type="html"><![CDATA[<h3 id="数组">数组</h3><p>数组是由相同类型元素的集合组成的数据结构, 计算机会为数组分配一块连续的内存来保存其中的元素</p><p>数组是定长的, 必须指定长度或满足编译器对数组大小的推导</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><br>arr1 := [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>arr2 := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="切片">切片</h3><p>切片类型的声明方式与数组有一些相似, 不过由于切片的长度是动态的, 所以声明时只需要指定切片中的元素类型</p><p>数据结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> SliceHeader <span class="hljs-keyword">struct</span> &#123;<br>Data <span class="hljs-type">uintptr</span><br>Len  <span class="hljs-type">int</span><br>Cap  <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>Data 是指向数组的指针;</p><p>Data 是一片连续的内存空间, 这片内存空间可以用于存储切片中的全部元素, 数组中的元素只是逻辑上的概念, 底层存储其实都是连续的, 所以我们可以将切片理解成一片连续的内存空间加上长度与容量的标识</p></li><li><p>Len 是当前切片的长度；</p></li><li><p>Cap 是当前切片的容量, 即 Data 数组的大小,</p></li></ul><p>程序在运行区间可以修改它的长度和范围。当切片底层的数组长度不足时就会触发扩容, 切片指向的数组可能会发生变化, 不过在上层看来切片是没有变化的, 上层只需要与切片打交道不需要关心数组的变化</p><h4 id="扩容">扩容</h4><p>在分配内存空间之前需要先确定新的切片容量, 运行时根据切片的当前容量选择不同的策略进行扩容：</p><ul><li>如果期望容量大于当前容量的两倍就会使用期望容量；</li><li>如果当前切片的长度小于 1024 就会将容量翻倍；</li><li>如果当前切片的长度大于 1024 就会每次增加 25% 的容量, 直到新容量大于期望容量；</li></ul><h4 id="copy">copy</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">slicecopy</span><span class="hljs-params">(to, fm slice, width <span class="hljs-type">uintptr</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> fm.<span class="hljs-built_in">len</span> == <span class="hljs-number">0</span> || to.<span class="hljs-built_in">len</span> == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br>n := fm.<span class="hljs-built_in">len</span><br><span class="hljs-keyword">if</span> to.<span class="hljs-built_in">len</span> &lt; n &#123;<br>n = to.<span class="hljs-built_in">len</span><br>&#125;<br><span class="hljs-keyword">if</span> width == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> n<br>&#125;<br>...<br><br>size := <span class="hljs-type">uintptr</span>(n) * width<br><span class="hljs-keyword">if</span> size == <span class="hljs-number">1</span> &#123;<br>*(*<span class="hljs-type">byte</span>)(to.array) = *(*<span class="hljs-type">byte</span>)(fm.array)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// runtime.memmove 将整块内存的内容拷贝到目标的内存区域中</span><br>memmove(to.array, fm.array, size)<br>&#125;<br><span class="hljs-keyword">return</span> n<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang mutex</title>
    <link href="/2023/01/03/golang/mutex/"/>
    <url>/2023/01/03/golang/mutex/</url>
    
    <content type="html"><![CDATA[<p>参考 ：</p><p><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives">https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives</a></p><p><a href="https://www.bilibili.com/video/BV1hv411x7we">https://www.bilibili.com/video/BV1hv411x7we</a></p><h4 id="mutex">mutex</h4><p>sync.Mutex 由两个字段 state 和 sema 组成。其中 state 表示当前互斥锁的状态, 而 sema 是用于控制锁状态的信号量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-keyword">type</span> Mutex <span class="hljs-keyword">struct</span> &#123;<br>    state <span class="hljs-type">int32</span><br>    sema  <span class="hljs-type">uint32</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/asset/golang/images/mutex.png" alt="mutex"></p><p>state 最低三位表示mutexLocked, mutexWoken,  mutexStarving</p><ul><li>mutexLocked 表示互斥锁的锁定状态；</li><li>mutexWoken — 表示从正常模式被从唤醒；</li><li>mutexStarving — 当前的互斥锁进入饥饿状态；</li></ul><p>其余位置表示当前互斥锁上等待的 Goroutine 个数</p><h4 id="正常模式">正常模式</h4><p>一个尝试加锁的Goroutine会先自旋几次, 尝试通过原子操作获取锁, 若获取不到锁, 就通过信号量排队等待(先进先出),<br>当锁释放是, 第一个排队等待的Goroutine会被唤醒, 与处于自旋状态,且没有在排队的Goroutine争取锁, 被唤醒的Goroutine没有获取锁会返回队列排在第一位,当一个Goroutine处于等待时长超过1ms,当前状态切换为饥饿状态</p><h4 id="饥饿模式">饥饿模式</h4><p>mutex的所有权直接从执行Unlock的Goroutine交给等待队列头部的Goroutine, 后来者不会自旋且不会尝试获得锁, 直接在队列排队等待获取锁</p><p>切换正常模式：</p><ul><li>当等待者获取锁之后, 且等待时长小于1ms</li><li>当前等待者是队列种最后一个获取锁的Goroutine</li></ul><h5 id="为什么需要自旋">为什么需要自旋</h5><p>避免频繁的挂起, 唤醒Goroutine带来的开销</p><h5 id="为什么等待需要和自旋争取-为什么自旋的Goroutine争取锁更有优势">为什么等待需要和自旋争取/为什么自旋的Goroutine争取锁更有优势</h5><p>处于自旋的Goroutine正在CPU上运行, 可以避免不必要的上下文切换, 处于自旋的Goroutine可能有很多个, 队列种被唤醒的Goroutine只有一个, 所以被唤醒的Goroutine大概率拿不到锁</p><h4 id="触发自旋的条件">触发自旋的条件</h4><ol><li><p>锁已经被占用，且锁不处于饥饿状态</p></li><li><p>累计的自旋次数，小于最大自旋次数（active_spin=4）</p></li><li><p>cpu 核数大于1</p></li><li><p>有空闲的P</p></li><li><p>当前 goroutine 锁挂载的P下，本地运行G队列为空</p></li></ol><p>sync.Mutex 有两种模式</p><ul><li>正常模式和饥饿模式。</li></ul><p>我们需要在这里先了解正常模式和饥饿模式都是什么以及它们有什么样的关系</p><p>在正常模式下, 锁的等待者会按照先进先出的顺序获取锁。但是刚被唤起的 Goroutine 与新创建的 Goroutine 竞争时, 大概率会获取不到锁, 为了减少这种情况的出现, 一旦 Goroutine 超过 1ms 没有获取到锁, 它就会将当前互斥锁切换饥饿模式, 防止部分 Goroutine 被『饿死』</p><p>在饥饿模式中, 互斥锁会直接交给等待队列最前面的 Goroutine。新的 Goroutine 在该状态下不能获取锁、也不会进入自旋状态, 它们只会在队列的末尾等待。如果一个 Goroutine 获得了互斥锁并且它在队列的末尾或者它等待的时间少于 1ms, 那么当前的互斥锁就会切换回正常模式</p>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang make和new</title>
    <link href="/2023/01/02/golang/make_new/"/>
    <url>/2023/01/02/golang/make_new/</url>
    
    <content type="html"><![CDATA[<ul><li>make 的作用是初始化内置的数据结构, 也就是我们在前面提到的切片、哈希表和 Channel</li><li>new 的作用是根据传入的类型分配一片内存空间并返回指向这片内存空间的指针</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang map</title>
    <link href="/2023/01/02/golang/map/"/>
    <url>/2023/01/02/golang/map/</url>
    
    <content type="html"><![CDATA[<p>参考 ：</p><p><a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/">https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/</a></p><p><a href="https://www.bilibili.com/video/BV1Sp4y1U7dJ">https://www.bilibili.com/video/BV1Sp4y1U7dJ</a></p><p>map是一堆键值对的未排序集合</p><p>hashmap 会存在哈希冲突</p><p>解决 hash 冲突办法：</p><ul><li>开放寻址法<ul><li>线性探测法：向后依次探测可以存放的位置, 直到找到为止（最坏情况下时间复杂度O(n)）</li><li>二次线性探测：当前key存在该地址后偏移量为（1,2,3…）的二次方地址处</li><li>双重散列：对hash值使用多组散列函数重新计算位置, 直到找到空闲位置为止</li></ul></li><li>拉链法: 每个位置对应一个链表, 查找key所在的链表, 然后在链表顺序查找位置</li></ul><p>golang map使用改进的拉链法解决冲突</p><p>map的底层是通过hmap（hashmap）来实现的</p><p>map底层数据结构</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs golang"><br><span class="hljs-keyword">type</span> hmap <span class="hljs-keyword">struct</span> &#123;<br>count     <span class="hljs-type">int</span> <span class="hljs-comment">//表示当前哈希表中的元素数量；</span><br>flags     <span class="hljs-type">uint8</span><br>B         <span class="hljs-type">uint8</span> <span class="hljs-comment">//表示当前哈希表持有的 buckets 数量, 但是因为哈希表中桶的数量都 2 的倍数, 所以该字段会存储对数, 也就是 len(buckets) == 2^B；</span><br>noverflow <span class="hljs-type">uint16</span><br>hash0     <span class="hljs-type">uint32</span> <span class="hljs-comment">//是哈希的种子, 它能为哈希函数的结果引入随机性, 这个值在创建哈希表时确定, 并在调用哈希函数时作为参数传入；</span><br><br>buckets    unsafe.Pointer <br>oldbuckets unsafe.Pointer <span class="hljs-comment">// 哈希在扩容时用于保存之前 buckets </span><br>nevacuate  <span class="hljs-type">uintptr</span> <span class="hljs-comment">// 渐进式扩容下一个需要迁移的旧桶的编号</span><br><br>extra *mapextra  <span class="hljs-comment">//记录的是溢出桶的相关信息</span><br>&#125;<br><br><span class="hljs-keyword">type</span> mapextra <span class="hljs-keyword">struct</span> &#123;<br>overflow    *[]*bmap<br>oldoverflow *[]*bmap<br>nextOverflow *bmap<br>&#125;<br><br><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;<br>    topbits  [<span class="hljs-number">8</span>]<span class="hljs-type">uint8</span><br>    keys     [<span class="hljs-number">8</span>]keytype<br>    values   [<span class="hljs-number">8</span>]valuetype<br>    pad      <span class="hljs-type">uintptr</span><br>    overflow <span class="hljs-type">uintptr</span> <span class="hljs-comment">// 指向溢出的桶</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>hmap<br><img src="/asset/golang/images/hmap.png" alt="hmap"></p><p>bmap<br><img src="/asset/golang/images/bmap.png" alt="bmap"></p><p>如果哈希表要分配的桶的数目大于2^4, 就认为会使用到溢出桶的几率比较大, 就会预分配2^(B-4)个溢出桶, 溢出桶和常规桶在内存中是连续的</p><p>map 扩容的负载因子是6.5</p><p><code>Load factor = count/(2^B)</code></p><p>负载因子超过6.5会触发<strong>翻倍扩容</strong></p><p>如果负载因子没有超标, 使用的溢出桶过多, 触发<strong>等量扩容</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">B</span> &lt;= <span class="hljs-number">15</span>, noverflow(溢出桶) &gt;= <span class="hljs-number">2</span>^B<br><span class="hljs-attribute">B</span> &gt; <span class="hljs-number">15</span>, noverflow(溢出桶) &gt;= <span class="hljs-number">2</span>^<span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><p>为什么要等量扩容, 因为负载因子过低, 也就是count太低, 表示大量进行了删除操作, 等量扩容可以使正常桶和溢出桶中的元素可以合并, 从而减少溢出桶的使用</p><h3 id="map-查找过程">map 查找过程</h3><ol><li><p>根据key值算出哈希值</p></li><li><p>取哈希值低位与hmap.B取模确定bucket位置</p></li><li><p>取哈希值高位在tophash数组中查询</p></li><li><p>如果tophash[i]中存储值也哈希值相等，则去找到该bucket中的key值进行比较</p></li><li><p>当前bucket没有找到，则继续从下个overflow的bucket中查找。</p></li><li><p>如果当前处于搬迁过程，则优先从oldbuckets查找</p></li></ol><h3 id="插入过程">插入过程</h3><ol><li>根据key值算出哈希值</li><li>取哈希值低位与hmap.B取模确定bucket位置</li><li>查找该key是否已经存在，如果存在则直接更新值</li><li>如果没找到将key，将key插入</li></ol><h3 id="map-的key必须是可以比较的">map 的key必须是可以比较的</h3>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>coding手册</title>
    <link href="/2023/01/01/%E5%9F%BA%E7%A1%80/coding%E6%89%8B%E5%86%8C/"/>
    <url>/2023/01/01/%E5%9F%BA%E7%A1%80/coding%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="时间处理">时间处理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 获取毫秒时间戳</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>() <br><span class="hljs-comment">// 自定义格式</span><br><span class="hljs-title function_">moment</span>().<span class="hljs-title function_">format</span>(<span class="hljs-string">&#x27;YYYY-MM-DD HH:mm:ss&#x27;</span>);<br><span class="hljs-title function_">moment</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()).<span class="hljs-title function_">format</span>(<span class="hljs-string">&#x27;YYYY-MM-DD HH:mm:ss&#x27;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 获取毫秒时间戳</span><br>time.Now().UnixMilli()<br><span class="hljs-comment">// 自定义格式</span><br>time.Now().Format(<span class="hljs-string">&quot;2006-01-02 15:04:05&quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">// 获取毫秒时间戳<br>time.time()<br>// 自定义格式<br>datetime.now().strftime(<span class="hljs-string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>coding手册</tag>
      
      <tag>参考资料</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GMP</title>
    <link href="/2022/12/31/golang/gmp/"/>
    <url>/2022/12/31/golang/gmp/</url>
    
    <content type="html"><![CDATA[<p>Go 语言的协程 goroutine<br>Go 为了提供更容易使用的并发方法, 使用了 goroutine 和 channel。goroutine 来自协程的概念, 让一组可复用的函数运行在一组线程之上, 即使有协程阻塞, 该线程的其他协程也可以被 runtime 调度, 转移到其他可运行的线程上。最关键的是, 程序员看不到这些底层的细节, 这就降低了编程的难度, 提供了更容易的并发。</p><p>Go 中, 协程被称为 goroutine, 它非常轻量, 一个 goroutine 只占几 KB, 并且这几 KB 就足够 goroutine 运行完, 这就能在有限的内存空间内支持大量 goroutine, 支持了更多的并发。虽然一个 goroutine 的栈只占几 KB, 但实际是可伸缩的, 如果需要更多内容, runtime 会自动为 goroutine 分配。</p><p>Goroutine 特点：</p><p>占用内存更小（几 kb）<br>调度更灵活 (runtime 调度)</p><p>goroutine 基于GMP调度模型完成</p><h3 id="设计原理">设计原理</h3><h4 id="单线程调度器-0-x">单线程调度器 0.x</h4><p>调度器只包含表示 Goroutine 的 G(协程) 和表示线程的 M(线程) 两种结构, 全局也只有一个线程</p><h4 id="多线程调度器-1-0">多线程调度器 1.0</h4><p>多线程调度器引入了 GOMAXPROCS 变量帮助我们灵活控制程序中的最大处理器数, 即活跃线程数</p><h4 id="任务窃取调度器-1-1">任务窃取调度器 1.1</h4><p>在多线程调度器上进行改进</p><ul><li>在当前的 G-M 模型中引入了处理器 P, 增加中间层</li><li>在处理器 P 的基础上实现基于工作窃取的调度器</li></ul><h4 id="抢占式调度器-·-1-2-至今">抢占式调度器 · 1.2 ~ 至今</h4><ul><li>基于协作的抢占式调度器 - 1.2 ~ 1.13<ul><li>通过编译器在函数调用时插入抢占检查指令, 在函数调用时检查当前 Goroutine 是否发起了抢占请求, 实现基于协作的抢占式调度；</li><li>Goroutine 可能会因为垃圾回收和循环长时间占用资源导致程序暂停；</li></ul></li><li>基于信号的抢占式调度器 - 1.14 ~ 至今<ul><li>实现<strong>基于信号的真抢占式调度</strong>；</li><li>垃圾回收在扫描栈时会触发抢占调度；</li><li>抢占的时间点不够多, 还不能覆盖全部的边缘情况；</li></ul></li></ul><p>对 Go 语言并发模型的修改提升了调度器的性能, 但是 1.1 版本中的调度器仍然不支持抢占式调度, 程序只能依靠 Goroutine 主动让出 CPU 资源才能触发调度</p><h5 id="基于协作的抢占式调度器">基于协作的抢占式调度器</h5><p>Go 语言的调度器在 1.2 版本中引入基于协作的抢占式调度解决下面的问题：</p><ul><li>某些 Goroutine 可以长时间占用线程, 造成其它 Goroutine 的饥饿</li><li>垃圾回收需要暂停整个程序（Stop-the-world, STW）, 最长可能需要几分钟的时间, 导致整个程序无法工作</li></ul><p>1.2 版本的抢占式调度虽然能够缓解这个问题, 但是它实现的抢占式调度是基于协作的, 在之后很长的一段时间里 Go 语言的调度器都有一些无法被抢占的边缘情况, 例如：for 循环或者垃圾回收长时间占用线程, 这些问题中的一部分直到 1.14 才被基于信号的抢占式调度解决</p><h5 id="基于信号的抢占式调度器">基于信号的抢占式调度器</h5><p>Go 语言在 1.14 版本中实现了非协作的抢占式调度, 在实现的过程中我们重构已有的逻辑并为 Goroutine 增加新的状态和字段来支持抢占。Go 团队通过下面的一系列提交实现了这一功能, 我们可以按时间顺序分析相关提交理解它的工作原理</p><h2 id="调度器的-GMP-模型">调度器的 GMP 模型</h2><p><img src="/asset/golang/images/GMP.png" alt="gmp"></p><p>Processor,虚拟处理器，M和G所需要的资源的上下文， 程序启动时创建, 最大 GOMAXPROCS 可以设置数量,  它包含了运行 goroutine 的资源, 如果M想运行 goroutine, 必须先获取 P, P 中还包含了可运行的 G 队列（最大256个）,</p><p>M , golang 对系统线程的封装, 真正执行代码必须要有线程, 操作系统分配到应用程序的内核线程数, 默认最大量10000个, 如果有M阻塞, 会创建一个新的M, 如果M空闲, M会被回收或者睡眠</p><p>新创建的G优先放在P的等待队列中, 如果G满了, 放入到全局的等待队列中</p><p>G的状态</p><pre><code class="hljs">- 空闲中 _Gidle刚刚被分配并且还没有被初始化- 等待运行 _Grunnable 没有执行代码，没有栈的所有权，存储在运行队列中- 运行中 _Grunning 可以执行代码，拥有栈的所有权，被赋予了内核线程 M 和处理器 P- 系统调用中 _Gsyscall 正在执行系统调用，拥有栈的所有权，没有执行用户代码，被赋予了内核线程 M 但是不在运行队列上- 等待中 _Gwaiting 由于运行时而被阻塞，没有执行用    _Gpreempted由于抢占而被阻塞，没有执行用户代码并且不在运行队列上，等待唤醒- 户代码并且不在运行队列上，但是可能存在于 Channel 的等待队列上- 已终止 _Gdead没有被使用，没有执行代码，可能有分配的栈- _Gcopystack栈正在被拷贝，没有执行代码，不在运行队列上</code></pre><h3 id="调度策略">调度策略</h3><ul><li><p>复用线程</p><ul><li><p>work-stealing</p><p>当前处理器本地的运行队列中不包含 G 时, 调用会触发工作窃取, 则去全局队列偷取一部分G，如果全局队列也是空的，则去其他的P中偷取一部分G</p><p>处理器持有一个由可运行的 Goroutine 组成的环形的运行队列 runq, 还反向持有一个线程。调度器在调度时会从处理器的队列中选择队列头的 Goroutine 放到线程 M 上执行</p><p>基于工作窃取的多线程调度器将每一个线程绑定到了独立的 CPU 上, 这些线程会被不同处理器管理, 不同的处理器通过工作窃取对任务进行再分配实现任务的平衡, 也能提升调度器和 Go 语言程序的整体性能, 今天所有的 Go 语言服务都受益于这一改动</p></li><li><p>hand off</p><p>当M处理的G,G处于阻塞时,M释放绑定的P，把P转移给其他空闲的M执行</p></li></ul></li><li><p>利用并行</p><p>GOMAXPROCS 设置P的数据，最多有GOMAXPROCS个线程分布在多个CPU执行</p></li><li><p>抢占<br>一个Goroutine 最多占用CPU 10ms,防止其他 Goroutine 饿死</p></li><li><p>全局 G 队列<br>当 M 执行 work-stealing 会获取全局队列的G</p></li></ul><h3 id="go-func-执行流程">go func() 执行流程</h3><ol><li>go func() 创建G，加入到 P 队列中</li><li>G只能在M中执行，M必须持有一个P，M与P是1:1的关系，M从P中取出G来执行</li><li>一个M调度G执行是一个循环机制(调度-&gt;执行-&gt;销毁-&gt;返回-&gt;调度)</li><li>如果G发生syscall或者阻塞，M会阻塞，如果当前有一些G在执行，runtime会把这个M从P中摘除（detach），重新创建或者拿取一个空闲线程用来服务P</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang Channel</title>
    <link href="/2022/12/30/golang/channel/"/>
    <url>/2022/12/30/golang/channel/</url>
    
    <content type="html"><![CDATA[<p>参考 ：</p><p><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel">https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel</a></p><p><a href="https://www.bilibili.com/video/BV1kh411n79h">https://www.bilibili.com/video/BV1kh411n79h</a></p><p>不要通过共享内存的方式进行通信, 而是应该通过通信的方式共享内存</p><p>Channel 是 Goroutine 之间的通信方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> hchan <span class="hljs-keyword">struct</span> &#123;<br>qcount   <span class="hljs-type">uint</span><br>dataqsiz <span class="hljs-type">uint</span><br>buf      unsafe.Pointer<br>elemsize <span class="hljs-type">uint16</span><br>closed   <span class="hljs-type">uint32</span><br>elemtype *_type<br>sendx    <span class="hljs-type">uint</span><br>recvx    <span class="hljs-type">uint</span><br>recvq    waitq<br>sendq    waitq<br><br>lock mutex<br>&#125;<br><br><span class="hljs-keyword">type</span> waitq <span class="hljs-keyword">struct</span> &#123;<br>first *sudog<br>last  *sudog<br>&#125;<br><br><span class="hljs-keyword">type</span> sudog <span class="hljs-keyword">struct</span> &#123;<br>g *g<br><br>next *sudog<br>prev *sudog<br>elem unsafe.Pointer <span class="hljs-comment">// data element (may point to stack)</span><br><br>acquiretime <span class="hljs-type">int64</span><br>releasetime <span class="hljs-type">int64</span><br>ticket      <span class="hljs-type">uint32</span><br><br>isSelect <span class="hljs-type">bool</span><br><br>success <span class="hljs-type">bool</span><br><br>parent   *sudog <span class="hljs-comment">// semaRoot binary tree</span><br>waitlink *sudog <span class="hljs-comment">// g.waiting list or semaRoot</span><br>waittail *sudog <span class="hljs-comment">// semaRoot</span><br>c        *hchan <span class="hljs-comment">// channel</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>qcount — Channel 中的元素个数；</li><li>dataqsiz — Channel 中的循环队列的长度；</li><li>buf — Channel 的缓冲区数据指针,是一个环形队列；</li><li>sendx — Channel 的发送操作处理到的位置；</li><li>recvx — Channel 的接收操作处理到的位置；</li><li>elemsize 和 elemtype 分别表示当前 Channel 能够收发的元素类型和大小</li><li>sendq 和 recvq 存储了当前 Channel 由于缓冲区空间不足而阻塞的 Goroutine 列表</li></ul><h3 id="发送数据">发送数据</h3><p>在发送数据的逻辑执行之前会先为当前 Channel 加锁, 防止多个线程并发修改数据。如果 Channel 已经关闭, 那么向该 Channel 发送数据时会报 “send on closed channel” 错误并中止程序</p><h4 id="直接发送-无缓冲">直接发送(无缓冲)</h4><p>如果目标 Channel 没有被关闭并且已经有处于读等待的 Goroutine, 会从接收队列 recvq 中取出最先陷入等待的 Goroutine 并直接向它发送数据</p><h4 id="发送有缓冲">发送有缓冲</h4><p>创建的 Channel 包含缓冲区并且 Channel 中的数据没有装满, 计算出下一个可以存储数据的位置, 然后将数据拷贝到环形队列中对应的位置上</p><h4 id="阻塞发送">阻塞发送</h4><p>会创建一个等待结构并将其加入 Channel 的 发送队列中, 当前 Goroutine 也会陷入阻塞, 等待其他的协程从 Channel 接收数据</p><h4 id="使用-select-关键字可以向-Channel-非阻塞地发送消息">使用 select 关键字可以向 Channel 非阻塞地发送消息</h4><p>runtime.selectnbsend()</p><p>本质上是在 chansend() 上加了判断</p><p>###接受消息</p><ul><li>当存在等待的发送者时, 从阻塞的发送者或者缓冲区中获取数据</li><li>当缓冲区存在数据时, 从 Channel 的缓冲区中接收数据</li><li>当缓冲区中不存在数据时, 等待其他 Goroutine 向 Channel 发送数据</li></ul><h4 id="直接接收-无缓冲">直接接收(无缓冲)</h4><p>将 Channel (sendq)发送队列中 Goroutine 存储的 elem 数据拷贝到目标内存地址中</p><h4 id="缓冲区有数据">缓冲区有数据</h4><p>如果 Channel 的 sendq 发送队列中存在挂起的 Goroutine, 会将 recvx 获取索引所在的数据拷贝到接收变量所在的内存空间上并将 sendq 发送队列中 Goroutine 的数据拷贝到缓冲区<br>, 然后直接读取 recvx 获取索引对应的数据</p><h4 id="缓冲区没有数据">缓冲区没有数据</h4><p>创建一个等待结构并将其加入 Channel 的接受队列中, 当前 Goroutine 陷入阻塞, 等待调度器的唤醒</p><h4 id="触发-Goroutine-调度的两个时机：">触发 Goroutine 调度的两个时机：</h4><ul><li>当 Channel 为空时；</li><li>当缓冲区中不存在数据并且也不存在数据的发送者时</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 定时器 cpu 使用率过高的问题</title>
    <link href="/2022/09/06/blog/golang/golang_time_cpu/"/>
    <url>/2022/09/06/blog/golang/golang_time_cpu/</url>
    
    <content type="html"><![CDATA[<p>早上打开电脑摸鱼的时候发现公司的测试环境的一个微服务CPU单核占用率到了99%,因为是核心服务,一直以为是处理业务逻辑的原因, 下午的时候就飙到了199%,而且很稳定的维持中,发现不对劲,去其他环境一看,果然这个服务的CPU占用率都不正常, 很可惜没有对这个服务开启pprof,找不到具体原因, 看看代码, 很顺利找到原因</p><p>看到代码时立马想到了当年看过群主的这篇<a href="https://xiaorui.cc/archives/5117">blog</a></p><p>原因还是锁抢占的问题</p><p>demo 如下</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs golang"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>     <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++ &#123;<br>       <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>         timeOut := time.NewTimer(time.Second * <span class="hljs-number">120</span>)<br>         t := time.NewTicker(time.Millisecond * <span class="hljs-number">50</span>)<br>         <span class="hljs-keyword">for</span> &#123;<br>           <span class="hljs-keyword">select</span> &#123;<br>           <span class="hljs-keyword">case</span> &lt;-t.C:<br>              ...check<br>           <span class="hljs-keyword">case</span> &lt;-timeOut.C:<br>             <span class="hljs-keyword">break</span><br>           &#125;<br>         &#125;<br>       &#125;()<br>     &#125;<br>   &#125;()<br> &#125;<br><br></code></pre></td></tr></table></figure><p>稍微加大协程运行等待一段时间,cpu占用率果然上来了</p><p><img src="/asset/blog/golang/images/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221228215317.jpg" alt="cpu占用率"></p><p>后来重构了这块代码,不在使用time.NewTicker才解决这个问题</p>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PDF</title>
    <link href="/2022/08/04/PDF/pdf/"/>
    <url>/2022/08/04/PDF/pdf/</url>
    
    <content type="html"><![CDATA[<hr><p><a href="https://pan.baidu.com/s/1LC_-Ptl7pxR2jXBKPyLHOg">Go八股文大全.pdf</a></p><p>提取码：b7ep</p><hr><p><a href="https://pan.baidu.com/s/1SdRD_1xHfVHZpYk2ltE4Lg">Go面试题new.pdf</a></p><p>提取码：o399</p><hr><p><a href="https://pan.baidu.com/s/1amYZ7Je5lqympHgYLWUfag">Kubernetes in Action中文版.pdf</a></p><p>提取码：77r2<br>docker run -d --name etcd-server --publish 2379:2379 --publish 2380:2380 --env ALLOW_NONE_AUTHENTICATION=yes --env ETCD_ADVERTISE_CLIENT_URLS=<a href="http://etcd-server:2379">http://etcd-server:2379</a> bitnami/etcd:latest</p>]]></content>
    
    
    
    <tags>
      
      <tag>PDF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NACOS 安装</title>
    <link href="/2022/07/20/%E4%B8%AD%E9%97%B4%E4%BB%B6/Nacos/install/"/>
    <url>/2022/07/20/%E4%B8%AD%E9%97%B4%E4%BB%B6/Nacos/install/</url>
    
    <content type="html"><![CDATA[<h4 id="docker-安装-NACOS">docker 安装 NACOS</h4><p>NACOS 当前版本  2.2.2</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><br>docker <span class="hljs-built_in">run</span> -d -p 8848:8848 -p 9848:9848 -e <span class="hljs-attribute">MODE</span>=standalone \<br>-e <span class="hljs-attribute">PREFER_HOST_MODE</span>=hostname \<br>-e <span class="hljs-attribute">NACOS_AUTH_ENABLE</span>=<span class="hljs-literal">true</span> \<br>-e <span class="hljs-attribute">NACOS_AUTH_IDENTITY_KEY</span>=test \<br>-e <span class="hljs-attribute">NACOS_AUTH_IDENTITY_VALUE</span>=test \<br>-e <span class="hljs-attribute">NACOS_AUTH_TOKEN</span>=MTIzNDU2Nzg5MTIzNDU2Nzg5MTIzNDU2Nzg5MTIzNDU2Nzg5 \<br>-v <span class="hljs-variable">$HOME</span>/nacos/logs:/home/nacos/logs \<br>--restart always --name nacos nacos/nacos-server<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">访问地址 http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8848</span>/nacos<br>默认账号密码 <br>nacos<br>nacos<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">挂载自定义config,需要<br><br>-v <span class="hljs-variable">$HOME</span><span class="hljs-regexp">/nacos/</span>config<span class="hljs-regexp">/application.properties:/</span>home<span class="hljs-regexp">/nacos/</span>conf/application.properties \<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>NACOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务框架 go-micro 使用 Kafka 作为发布订阅的 Broker</title>
    <link href="/2022/06/26/blog/golang/go_micro_use_kafka/"/>
    <url>/2022/06/26/blog/golang/go_micro_use_kafka/</url>
    
    <content type="html"><![CDATA[<h3 id="微服务框架-go-micro-使用-Kafka-作为发布订阅的-Broker">微服务框架 go-micro 使用 Kafka 作为发布订阅的 Broker</h3><p>go-micro 默认使用http服务作为服务中的Broker</p><p>服务默认启动的时候</p><p><img src="/asset/blog/golang/images/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230226174740.png" alt="http"></p><p>使用kafka启动<br><img src="/asset/blog/golang/images/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230226180820.png" alt="kafka"></p><p>http服务作为服务中的Broker，有三个明显的缺点：</p><ol><li><p>不能持久化存储</p></li><li><p>不能对未消费的数据，进行消费</p></li><li><p>每个需要发送消息的微服务都会启动一个 http Broker服务，可能会影响服务器性能</p></li></ol><p>broker interface</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Broker <span class="hljs-keyword">interface</span> &#123;<br>Init(...Option) <span class="hljs-type">error</span><br>Options() Options<br>Address() <span class="hljs-type">string</span><br>Connect() <span class="hljs-type">error</span><br>Disconnect() <span class="hljs-type">error</span><br>Publish(topic <span class="hljs-type">string</span>, m *Message, opts ...PublishOption) <span class="hljs-type">error</span><br>Subscribe(topic <span class="hljs-type">string</span>, h Handler, opts ...SubscribeOption) (Subscriber, <span class="hljs-type">error</span>)<br>String() <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>go-micro plugin也集成了 Kafka</p><p>接受端接受消息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;github.com/micro/go-micro/v2&quot;</span><br><span class="hljs-string">&quot;github.com/micro/go-micro/v2/metadata&quot;</span><br><span class="hljs-string">&quot;github.com/micro/go-micro/v2/util/log&quot;</span><br>proto <span class="hljs-string">&quot;go14/micro/cmds/pubsub/push/proto&quot;</span><br><br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;github.com/micro/go-micro/v2/broker&quot;</span><br><span class="hljs-string">&quot;github.com/micro/go-plugins/broker/kafka/v2&quot;</span><br>)<br><br><span class="hljs-comment">// Sub 结构体所有能被暴露的方法都会执行消息处理的逻辑</span><br><span class="hljs-keyword">type</span> Sub <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Sub)</span></span> Process(ctx context.Context, event *proto.Event) <span class="hljs-type">error</span> &#123;<br>md, _ := metadata.FromContext(ctx)<br>log.Logf(<span class="hljs-string">&quot;[pubsub.1] Received event %+v with metadata %+v\n&quot;</span>, event, md)<br><span class="hljs-comment">// do something with event</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// func 形式也能处理对应的event</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subEv</span><span class="hljs-params">(ctx context.Context, event *proto.Event)</span></span> <span class="hljs-type">error</span> &#123;<br>md, _ := metadata.FromContext(ctx)<br>log.Logf(<span class="hljs-string">&quot;[pubsub.2] Received event %+v with metadata %+v\n&quot;</span>, event, md)<br><span class="hljs-comment">// do something with event</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-comment">// 设置DefaultBroker为 kafka 的 Broker</span><br>broker.DefaultBroker = kafka.NewBroker()<br><span class="hljs-comment">// init kafka的地址</span><br><span class="hljs-keyword">if</span> err := broker.Init(broker.Addrs(<span class="hljs-string">&quot;192.168.163.121:9092&quot;</span>),); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Broker Init error: %v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-comment">// 创建service</span><br>service := micro.NewService(<br>micro.Name(<span class="hljs-string">&quot;go.micro.srv.pubsub&quot;</span>),<br>micro.Broker(broker.DefaultBroker),<br>)<br><br><span class="hljs-comment">// 订阅消息</span><br><span class="hljs-keyword">if</span> err := micro.RegisterSubscriber(<span class="hljs-string">&quot;example.topic.pubsub.1&quot;</span>, service.Server(), <span class="hljs-built_in">new</span>(Sub));err !=<span class="hljs-literal">nil</span>&#123;<br>log.Fatalf(<span class="hljs-string">&quot;RegisterSubscriber Init error: %v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-keyword">if</span> err := micro.RegisterSubscriber(<span class="hljs-string">&quot;example.topic.pubsub.2&quot;</span>, service.Server(), subEv);err !=<span class="hljs-literal">nil</span>&#123;<br>log.Fatalf(<span class="hljs-string">&quot;RegisterSubscriber Init error: %v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-keyword">if</span> err := service.Run(); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>发送端发送消息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;github.com/micro/go-micro/v2/client&quot;</span><br><span class="hljs-string">&quot;strconv&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br><br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;github.com/micro/go-micro/v2&quot;</span><br><span class="hljs-string">&quot;github.com/micro/go-micro/v2/util/log&quot;</span><br>proto <span class="hljs-string">&quot;go14/micro/cmds/pubsub/push/proto&quot;</span><br><br><span class="hljs-string">&quot;github.com/micro/go-micro/v2/broker&quot;</span><br><span class="hljs-string">&quot;github.com/micro/go-plugins/broker/kafka/v2&quot;</span><br>)<br><br><span class="hljs-comment">// 发送消息</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sendEv</span><span class="hljs-params">(topic <span class="hljs-type">string</span>, p micro.Publisher)</span></span> &#123;<br>t := time.NewTicker(time.Second)<br><br><span class="hljs-keyword">for</span> _ = <span class="hljs-keyword">range</span> t.C &#123;<br><span class="hljs-comment">// 创建消息结构</span><br>ev := &amp;proto.Event&#123;<br>Id: strconv.FormatInt(time.Now().Unix(), <span class="hljs-number">10</span>),<br>Timestamp: time.Now().Unix(),<br>Message:   fmt.Sprintf(<span class="hljs-string">&quot;Messaging you all day on %s&quot;</span>, topic),<br>&#125;<br>log.Logf(<span class="hljs-string">&quot;publishing %+v\n&quot;</span>, ev)<br><span class="hljs-comment">// publish 消息</span><br><span class="hljs-keyword">if</span> err := p.Publish(context.Background(), ev); err != <span class="hljs-literal">nil</span> &#123;<br>log.Logf(<span class="hljs-string">&quot;error publishing: %v&quot;</span>, err)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 设置DefaultBroker为 kafka 的 Broker</span><br>broker.DefaultBroker = kafka.NewBroker()<br><span class="hljs-comment">// init kafka的地址</span><br><span class="hljs-keyword">if</span> err := broker.Init(broker.Addrs(<span class="hljs-string">&quot;192.168.163.121:9092&quot;</span>),); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Broker Init error: %v&quot;</span>, err)<br>&#125;<br><br>service := micro.NewService(<br>micro.Name(<span class="hljs-string">&quot;go.micro.cli.pubsub&quot;</span>),<br>)<br><br>_ = service.Client().Init(client.Broker(broker.DefaultBroker))<br><span class="hljs-comment">// create publisher</span><br>pub1 := micro.NewEvent(<span class="hljs-string">&quot;example.topic.pubsub.1&quot;</span>, service.Client())<br>pub2 := micro.NewEvent(<span class="hljs-string">&quot;example.topic.pubsub.2&quot;</span>, service.Client())<br><br><span class="hljs-comment">// pub to topic 1</span><br><span class="hljs-keyword">go</span> sendEv(<span class="hljs-string">&quot;example.topic.pubsub.1&quot;</span>, pub1)<br><span class="hljs-comment">// pub to topic 2</span><br><span class="hljs-keyword">go</span> sendEv(<span class="hljs-string">&quot;example.topic.pubsub.2&quot;</span>, pub2)<br><br><span class="hljs-keyword">select</span> &#123;&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>pubsub.proto</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs proto">syntax = &quot;proto3&quot;;<br>package pubsub;<br>option go_package=&quot;/grpc&quot;;<br>// Example message<br>message Event &#123;<br>  // unique id<br>  string id = 1;<br>  // unix timestamp<br>  int64 timestamp = 2;<br>  // message<br>  string message = 3;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>go-micro</tag>
      
      <tag>Kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器时间导致服务崩溃</title>
    <link href="/2022/04/06/blog/article/bug_for_the_server_date/"/>
    <url>/2022/04/06/blog/article/bug_for_the_server_date/</url>
    
    <content type="html"><![CDATA[<h3 id="center-服务器时间导致服务崩溃-center"><center>服务器时间导致服务崩溃</center></h3><p>测试反馈最近版本发布完,内网演示环境服务测试的时候,服务卡顿明细,让我找找问题</p><p>爬到服务器上一看,数据库负载到了20多</p><p>top + iostat 一看, 好家伙, 磁盘IO拉满了</p><p>假装分析一波发现 mongodump 这个进程在 top 中排第一位, 原来是在备份数据啊,忙问了一下领导, 回复说没有进行数据备份</p><p>仔细想了一下 crontab 里面有定时数据库备份的任务,凌晨3点会定时备份数据库</p><p>查看了一下服务器的 date 发现时区是标准时区导致凌晨3点备份数据实际是上午11点</p><p>此时又想起上次一个问题, 服务端因为时间问题校验用户 Token 永远是过期的,导致用户一直在生成新的Token, 进行校验, 几分钟调用了十几万次生成Token接口</p><p>令人感慨,可真是明明一点点小问题,却直接能把服务弄崩溃</p>]]></content>
    
    
    
    <tags>
      
      <tag>思考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka 消息队列</title>
    <link href="/2022/03/20/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/Kafka/"/>
    <url>/2022/03/20/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/Kafka/</url>
    
    <content type="html"><![CDATA[<h3 id="Kafka特点：">Kafka特点：</h3><pre><code class="hljs">1 解耦合 消息队列提供了借口, 生产者和消费者能够独立的完成读操作和写操作。2 高吞吐率。即使是在廉价的商用机器上也能做到单机支持每秒100K条消息的传输3 信息传输快。以时间复杂度为O（1）的方式提供持久化能力, 即使对TB级以上数据也能保证常数时间的访问性能4 可提供持久化。消息存储在中间件上, 数据持久化, 直到全部被处理完, 通过这一方式规避了数据丢失的风险</code></pre><h3 id="Kafka适用场景">Kafka适用场景</h3><pre><code class="hljs">根据上述功能和特点, Kafka主要有以下使用场景：信息系统 Messaging 。 在这个领域中, Kafka常常被拿来与传统的消息中间件进行对比, 如RabbitMQ。网站活动追踪 Website Activity Tracking监控 Metrics日志收集 Log Aggregation流处理 Stream Processing事件溯源 Event Sourcing提交日志 Commit Log</code></pre><p><img src="/asset/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/images/kafka.jpeg" alt="Kafka架构"></p><h3 id="Kafka架构图">Kafka架构图</h3><pre><code class="hljs">Producer ： 消息生产者, 就是向 Kafka发送数据 ；Consumer ： 消息消费者, 从 Kafka broker 取消息的客户端；Consumer Group （CG）： 消费者组, 由多个 consumer 组成。 消费者组内每个消费者负责消费不同分区的数据, 一个分区只能由一个组内消费者消费；消费者组之间互不影响。 所有的消费者都属于某个消费者组, 即消费者组是逻辑上的一个订阅者。Broker ：经纪人 一台 Kafka 服务器就是一个 broker。一个集群由多个 broker 组成。一个 broker可以容纳多个 topic。Topic ： 话题, 可以理解为一个队列,  生产者和消费者面向的都是一个 topic；Partition： 为了实现扩展性, 一个非常大的 topic 可以分布到多个 broker（即服务器）上, 一个 topic 可以分为多个 partition, 每个 partition 是一个有序的队列；如果一个topic中的partition有5个, 那么topic的并发度为5.Replica： 副本（Replication）, 为保证集群中的某个节点发生故障时,  该节点上的 partition 数据不丢失, 且 Kafka仍然能够继续工作,  Kafka 提供了副本机制, 一个 topic 的每个分区都有若干个副本, 一个 leader 和若干个 follower。Leader： 每个分区多个副本的“主”, 生产者发送数据的对象, 以及消费者消费数据的对象都是 leader。Follower： 每个分区多个副本中的“从”, 实时从 leader 中同步数据, 保持和 leader 数据的同步。 leader 发生故障时, 某个 Follower 会成为新的 leader。Offset ： 每个Consumer 消费的信息都会有自己的序号, 我们称作当前队列的offset。即消费点位标识消费到的位置。每个消费组都会维护订阅的Topic 下每个队列的offset</code></pre><h3 id="安装">安装</h3><p>阿里云镜像地址: <a href="http://mirrors.aliyun.com/apache/kafka/">http://mirrors.aliyun.com/apache/kafka/</a></p><p>下载 kafka_2.13-3.2.1.tgz</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br><span class="hljs-comment"># 解压</span><br>tar zxvf kafka_2.<span class="hljs-number">13</span>-<span class="hljs-number">3.2</span>.<span class="hljs-number">1</span>.tgz -C <span class="hljs-regexp">/opt/m</span>odule<br><br><span class="hljs-comment"># 运行</span><br>cd <span class="hljs-regexp">/opt/m</span>odule<br><br><span class="hljs-comment"># 启动zookeeper</span><br>.<span class="hljs-regexp">/bin/</span>zookeeper-server-start.sh  config/zookeeper.properties<br><br><span class="hljs-comment"># 后台启动</span><br>.<span class="hljs-regexp">/bin/</span>zookeeper-server-start.sh -daemon config/zookeeper.properties <br><br><span class="hljs-comment"># 启动kafka</span><br>.<span class="hljs-regexp">/bin/</span>kafka-server-start.sh config/server.properties<br><br><span class="hljs-comment"># 后台启动</span><br>.<span class="hljs-regexp">/bin/</span>kafka-server-start.sh -daemon config/server.properties<br><br></code></pre></td></tr></table></figure><h3 id="一个-docker-的集群例子">一个 docker 的集群例子</h3><p>docker-compose.yaml</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">version</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;3&quot;</span><br><br><span class="hljs-attribute">services</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">zookeeper</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#x27;bitnami/zookeeper:3.6&#x27;</span><br>    <span class="hljs-attribute">container_name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">zookeeper</span><br>    <span class="hljs-attribute">ports</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;2181:2181&#x27;</span><br>    <span class="hljs-attribute">environment</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-comment"># 匿名登录--必须开启</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ALLOW_ANONYMOUS_LOGIN=yes</span><br>      <span class="hljs-comment">#volumes:</span><br>      <span class="hljs-comment">#- ./zookeeper:/bitnami/zookeeper</span><br>    <span class="hljs-comment"># restart: always</span><br><br>  <span class="hljs-attribute">kafka1</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#x27;bitnami/kafka:3.0&#x27;</span><br>    <span class="hljs-attribute">container_name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">kafka1</span><br>    <span class="hljs-attribute">ports</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;9092:9092&#x27;</span><br>    <span class="hljs-attribute">environment</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">KAFKA_BROKER_ID=1</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">KAFKA_CFG_LISTENERS=PLAINTEXT://:9092</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">KAFKA_CFG_ADVERTISED_LISTENERS=PLAINTEXT://192.168.2.170:9092</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">KAFKA_CFG_ZOOKEEPER_CONNECT=zookeeper:2181</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ALLOW_PLAINTEXT_LISTENER=yes</span><br>    <span class="hljs-comment"># restart: always</span><br>    <span class="hljs-attribute">depends_on</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">zookeeper</span><br><br>  <span class="hljs-attribute">kafka2</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#x27;bitnami/kafka:3.0&#x27;</span><br>    <span class="hljs-attribute">container_name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">kafka2</span><br>    <span class="hljs-attribute">ports</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;9093:9093&#x27;</span><br>    <span class="hljs-attribute">environment</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">KAFKA_BROKER_ID=2</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">KAFKA_CFG_LISTENERS=PLAINTEXT://:9093</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">KAFKA_CFG_ADVERTISED_LISTENERS=PLAINTEXT://192.168.2.170:9093</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">KAFKA_CFG_ZOOKEEPER_CONNECT=zookeeper:2181</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ALLOW_PLAINTEXT_LISTENER=yes</span><br>    <span class="hljs-comment"># restart: always</span><br>    <span class="hljs-attribute">depends_on</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">zookeeper</span><br><br>  <span class="hljs-attribute">kafka3</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#x27;bitnami/kafka:3.0&#x27;</span><br>    <span class="hljs-attribute">container_name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">kafka3</span><br>    <span class="hljs-attribute">ports</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;9094:9094&#x27;</span><br>    <span class="hljs-attribute">environment</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">KAFKA_BROKER_ID=3</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">KAFKA_CFG_LISTENERS=PLAINTEXT://:9094</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">KAFKA_CFG_ADVERTISED_LISTENERS=PLAINTEXT://192.168.2.170:9094</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">KAFKA_CFG_ZOOKEEPER_CONNECT=zookeeper:2181</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ALLOW_PLAINTEXT_LISTENER=yes</span><br>    <span class="hljs-comment"># restart: always</span><br>    <span class="hljs-attribute">depends_on</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">zookeeper</span><br><br>  <span class="hljs-comment"># Web 管理界面 另外也可以用exporter+prometheus+grafana的方式来监控 https://github.com/danielqsj/kafka_exporter</span><br>  <span class="hljs-attribute">kafka_manager</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#x27;hlebalbau/kafka-manager:latest&#x27;</span><br>    <span class="hljs-attribute">container_name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">kafka-manager</span><br>    <span class="hljs-attribute">ports</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;9022:9000&quot;</span><br>    <span class="hljs-attribute">environment</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-attribute">ZK_HOSTS</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;zookeeper:2181&quot;</span><br>    <span class="hljs-comment"># restart: always</span><br>    <span class="hljs-attribute">depends_on</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">zookeeper</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">kafka1</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">kafka2</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">kafka3</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 AWS-SDK 上传文件到 MinIO</title>
    <link href="/2022/03/06/blog/golang/aws-s3-oss-go/"/>
    <url>/2022/03/06/blog/golang/aws-s3-oss-go/</url>
    
    <content type="html"><![CDATA[<p>公司内网环境自建的 MinIO 作为对象存储,而外网的对象存储则是使用的阿里云服务</p><p><code>MinIO</code>和<code>阿里云</code> 都兼容亚马逊(AWS) 的S3协议, 为此使用 AWS-SDK 上传服务生成的数据内容</p><p>docker 创建一个 MinIO 的容器</p><p>MINIO_ROOT_USER 和 MINIO_ROOT_PASSWORD 就是 9001 端口的登录的账号密码, 也是AK和SK(也可以进入后台自己更换)</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run -p <span class="hljs-number">9000</span>:<span class="hljs-number">9000</span> -p <span class="hljs-number">9001</span>:<span class="hljs-number">9001</span> --name minio1 -v ~<span class="hljs-regexp">/minio/</span>data:<span class="hljs-regexp">/data -e &quot;MINIO_ROOT_USER=AKIAIOSFODNN7EXAMPLE&quot; -e &quot;MINIO_ROOT_PASSWORD=wJalrXUtnFEMI/</span>K7MDENG<span class="hljs-regexp">/bPxRfiCYEXAMPLEKEY&quot; quay.io/mi</span>nio<span class="hljs-regexp">/minio server /</span>data --console-address <span class="hljs-string">&quot;:9001&quot;</span><br><br></code></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">go</span> <span class="hljs-built_in">get</span> github.<span class="hljs-keyword">com</span>/aws/aws-sdk-go@v1.<span class="hljs-number">44.70</span><br></code></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bytes&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;github.com/aws/aws-sdk-go/aws&quot;</span><br><span class="hljs-string">&quot;github.com/aws/aws-sdk-go/aws/credentials&quot;</span><br><span class="hljs-string">&quot;github.com/aws/aws-sdk-go/aws/session&quot;</span><br><span class="hljs-string">&quot;github.com/aws/aws-sdk-go/service/s3&quot;</span><br><span class="hljs-string">&quot;github.com/aws/aws-sdk-go/service/s3/s3manager&quot;</span><br>_ <span class="hljs-string">&quot;github.com/aws/aws-sdk-go/service/s3/s3manager&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewSess</span><span class="hljs-params">()</span></span> *session.Session &#123;<br>access_key := <span class="hljs-string">&quot;AKIAIOSFODNN7EXAMPLE&quot;</span><br>secret_key := <span class="hljs-string">&quot;wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY&quot;</span><br>end_point := <span class="hljs-string">&quot;http://192.168.163.121:9000&quot;</span> <span class="hljs-comment">//endpoint设置, 不要动</span><br><br><br>sess, err := session.NewSession(&amp;aws.Config&#123;<br>        <span class="hljs-comment">// credentials.NewStaticCredentials 这里第三个参数是token, 在使用 aliyun-sdk 时会获取的对应的值 </span><br>Credentials:      credentials.NewStaticCredentials(access_key, secret_key, <span class="hljs-string">&quot;&quot;</span>),<br>Endpoint:         aws.String(end_point),<br>Region:           aws.String(<span class="hljs-string">&quot;us-east-1&quot;</span>),<br>DisableSSL:       aws.Bool(<span class="hljs-literal">true</span>),<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">// false 会使用 virtual-host style方式,  http://192.168.163.121:9000 -&gt; http://bucket.192.168.163.121:9000</span><br><span class="hljs-comment">// true 会使用 强制使用路径方式,  http://192.168.163.121:9000 -&gt; http://192.168.163.121:9000/bucket</span><br><span class="hljs-comment">*/</span><br>S3ForcePathStyle: aws.Bool(<span class="hljs-literal">true</span>),<br>&#125;)<br><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">return</span> sess<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><br>get_bucket(NewSess())<br>get_file_and_folder(NewSess(), <span class="hljs-string">&quot;test&quot;</span>)<br>getFile(NewSess(), <span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;新建 文本文档.txt&quot;</span>)<br>uploadFile(NewSess(), <span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;新建 文本文档1.txt&quot;</span>, <span class="hljs-string">&quot;im data in 新建 文本文档1.txt&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">exitErrorf</span><span class="hljs-params">(msg <span class="hljs-type">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>fmt.Fprintf(os.Stderr, msg+<span class="hljs-string">&quot;&quot;</span>, args...)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">get_bucket</span><span class="hljs-params">(sess *session.Session)</span></span> &#123;<br><br>svc := s3.New(sess)<br>result, err := svc.ListBuckets(<span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>exitErrorf(<span class="hljs-string">&quot;Unable to list buckets, %v&quot;</span>, err)<br>&#125;<br><br>fmt.Println(<span class="hljs-string">&quot;Buckets:&quot;</span>)<br><br><span class="hljs-keyword">for</span> _, b := <span class="hljs-keyword">range</span> result.Buckets &#123;<br>fmt.Printf(<span class="hljs-string">&quot;* %s created on %s&quot;</span>,<br>aws.StringValue(b.Name), aws.TimeValue(b.CreationDate))<br>&#125;<br><br><span class="hljs-keyword">for</span> _, b := <span class="hljs-keyword">range</span> result.Buckets &#123;<br>fmt.Printf(<span class="hljs-string">&quot;\n%s&quot;</span>, aws.StringValue(b.Name))<br>&#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">get_file_and_folder</span><span class="hljs-params">(sess *session.Session, bucket <span class="hljs-type">string</span>)</span></span> &#123;<br><br><br><span class="hljs-comment">// bucket后跟, go run ....go bucketname</span><br>fmt.Println()<br>fmt.Println(bucket)<br><br>svc := s3.New(sess)<br><br>params := &amp;s3.ListObjectsInput&#123;<br>Bucket:             aws.String(fmt.Sprint(<span class="hljs-string">&quot;/&quot;</span>, bucket)),<br>Prefix:             aws.String(<span class="hljs-string">&quot;&quot;</span>),<br>&#125;<br>resp, err := svc.ListObjects(params)<br><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>exitErrorf(<span class="hljs-string">&quot;Unable to list items in bucket %q, %v&quot;</span>, bucket, err)<br>&#125;<br><br><span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> resp.Contents &#123;<br>fmt.Println(<span class="hljs-string">&quot;Name:         &quot;</span>, *item.Key)<br>fmt.Println(<span class="hljs-string">&quot;Last modified:&quot;</span>, *item.LastModified)<br>fmt.Println(<span class="hljs-string">&quot;Size:         &quot;</span>, *item.Size)<br>fmt.Println(<span class="hljs-string">&quot;Storage class:&quot;</span>, *item.StorageClass)<br>fmt.Println(<span class="hljs-string">&quot;&quot;</span>)<br>&#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getFile</span><span class="hljs-params">(sess *session.Session, bucket, item <span class="hljs-type">string</span>)</span></span> &#123;<br><br><br>file, err := os.Create(item)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>exitErrorf(<span class="hljs-string">&quot;Unable to open file %q, %v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-keyword">defer</span> file.Close()<br><br>downloader := s3manager.NewDownloader(sess)<br><br>numBytes, err := downloader.Download(file,<br>&amp;s3.GetObjectInput&#123;<br>Bucket: aws.String(fmt.Sprint(<span class="hljs-string">&quot;/&quot;</span>, bucket)),<br>Key:    aws.String(item),<br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>exitErrorf(<span class="hljs-string">&quot;Unable to download item %q, %v&quot;</span>, item, err)<br>&#125;<br><br>fmt.Println(<span class="hljs-string">&quot;Downloaded&quot;</span>, file.Name(), numBytes, <span class="hljs-string">&quot;bytes&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">uploadFile</span><span class="hljs-params">(sess *session.Session, bucket <span class="hljs-type">string</span>, filename, fileData <span class="hljs-type">string</span>)</span></span> &#123;<br><br>uploader := s3manager.NewUploader(sess)<br><br>_, err := uploader.Upload(&amp;s3manager.UploadInput&#123;<br>Bucket: aws.String(fmt.Sprint(<span class="hljs-string">&quot;/&quot;</span>, bucket)),<br>Key: aws.String(filename),<br>Body: bytes.NewReader([]<span class="hljs-type">byte</span>(fileData)),<br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// Print the error and exit.</span><br>exitErrorf(<span class="hljs-string">&quot;Unable to upload %q to %q, %v&quot;</span>, filename, bucket, err)<br>&#125;<br><br>fmt.Printf(<span class="hljs-string">&quot;Successfully uploaded %q to %q &quot;</span>, filename, bucket)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>MinIO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>etcd 超出空间导致服务注册不成功</title>
    <link href="/2022/03/06/blog/golang/etcd_space_exceeded/"/>
    <url>/2022/03/06/blog/golang/etcd_space_exceeded/</url>
    
    <content type="html"><![CDATA[<h3 id="center-etcd-超出空间导致服务注册不成功-center"><center> etcd 超出空间导致服务注册不成功</center></h3><p><code>keyword：mvcc: database space exceeded</code></p><p>go-micro 使用etcd作为注册中心, 公司当前处于的是业务开发状态, 发布订阅功能也是直接基于go-micro 使用etcd来做消息转存的,导致消息发布有大量消息没有及时处理, 堆积下来, 然后新服务不能写入注册信息到etcd中</p><p>上网搜索了一下,官方文档已经写的很清楚了 <a href="https://etcd.io/docs/v3.4/faq/#deployment">https://etcd.io/docs/v3.4/faq/#deployment</a> ,大意是, 为了防止性能下降或无意中使键值存储过载,etcd强制将可配置的存储大小配额默认设置为2GB</p><p>解决办法,执行下面命令清空磁盘,然后等待一段时间就行了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看警告信息</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">etcdctl --endpoints=http://127.0.0.1:2379 alarm list</span><br>  memberID:8630161756594109333 alarm:NOSPACE<br><span class="hljs-meta prompt_"># </span><span class="language-bash">获取当前版本</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">rev=$(etcdctl --endpoints=http://127.0.0.1:2379 endpoint status --write-out=<span class="hljs-string">&quot;json&quot;</span> | egrep -o <span class="hljs-string">&#x27;&quot;revision&quot;:[0-9]*&#x27;</span> | egrep -o <span class="hljs-string">&#x27;[0-9].*&#x27;</span>)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">压缩旧版本</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">etcdctl --endpoints=http://127.0.0.1:2379 compact <span class="hljs-variable">$rev</span></span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">清理磁盘碎片</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">etcdctl --endpoints=http://127.0.0.1:2379 defrag</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">最后验证空间是否释放</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">etcdctl endpoint status <span class="hljs-comment"># 惊人 G变成了M</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">最后清除警告</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">etcdctl --endpoints=http://127.0.0.1:2379 alarm disarm</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>etcd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在golang中使用 NACOS 管理项目的配置文件</title>
    <link href="/2022/02/26/blog/golang/nacos_demo_golang/"/>
    <url>/2022/02/26/blog/golang/nacos_demo_golang/</url>
    
    <content type="html"><![CDATA[<h3 id="center-在golang中使用-NACOS-管理项目的配置文件-center"><center> 在golang中使用 NACOS 管理项目的配置文件 </center></h3><ul><li><a href="../../%E4%B8%AD%E9%97%B4%E4%BB%B6/Nacos/install.md">安装Nacos</a></li></ul><p>nacos go</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">go get github.com/nacos-group/nacos-sdk-go/v2@v2.2.1<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;github.com/nacos-group/nacos-sdk-go/v2/clients&quot;</span><br><span class="hljs-string">&quot;github.com/nacos-group/nacos-sdk-go/v2/common/constant&quot;</span><br><span class="hljs-string">&quot;github.com/nacos-group/nacos-sdk-go/v2/vo&quot;</span><br>)<br><br><span class="hljs-comment">// NACOS 2.2.2</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-comment">//create clientConfig</span><br>clientConfig := constant.ClientConfig&#123;<br>NamespaceId:         <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">//we can create multiple clients with different namespaceId to support multiple namespace.When namespace is public, fill in the blank string here.</span><br>TimeoutMs:           <span class="hljs-number">500</span>,<br>NotLoadCacheAtStart: <span class="hljs-literal">true</span>,<br>LogDir:              <span class="hljs-string">&quot;.&quot;</span>,<br>CacheDir:            <span class="hljs-string">&quot;.&quot;</span>,<br>LogLevel:            <span class="hljs-string">&quot;debug&quot;</span>,<br>Username:            <span class="hljs-string">&quot;nacos&quot;</span>,<br>Password:            <span class="hljs-string">&quot;nacos&quot;</span>,<br>&#125;<br><br><span class="hljs-comment">// At least one ServerConfig</span><br>serverConfigs := []constant.ServerConfig&#123;<br>&#123;<br>IpAddr:      <span class="hljs-string">&quot;172.25.89.138&quot;</span>,<br>ContextPath: <span class="hljs-string">&quot;/nacos&quot;</span>,<br>Port:        <span class="hljs-number">8848</span>,<br>Scheme:      <span class="hljs-string">&quot;http&quot;</span>,<br>&#125;,<br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//IpAddr:      &quot;console2.nacos.io&quot;,</span><br><span class="hljs-comment">//ContextPath: &quot;/nacos&quot;,</span><br><span class="hljs-comment">//Port:        80,</span><br><span class="hljs-comment">//Scheme:      &quot;http&quot;,</span><br><span class="hljs-comment">//&#125;,</span><br>&#125;<br><br>configClient, err := clients.NewConfigClient(<br>vo.NacosClientParam&#123;<br>ClientConfig:  &amp;clientConfig,<br>ServerConfigs: serverConfigs,<br>&#125;,<br>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-comment">// 添加修改配置文件</span><br>ok, err := configClient.PublishConfig(vo.ConfigParam&#123;<br>DataId:  <span class="hljs-string">&quot;config_pre.yaml&quot;</span>,<br>Group:   <span class="hljs-string">&quot;DEFAULT_GROUP&quot;</span>,<br>Content: <span class="hljs-string">`ddd:123`</span>,<br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Println(ok)<br><span class="hljs-comment">// 查找配置文件</span><br>data, err := configClient.GetConfig(vo.ConfigParam&#123;<br>DataId: <span class="hljs-string">&quot;config_pre.yaml&quot;</span>,<br>Group:  <span class="hljs-string">&quot;DEFAULT_GROUP&quot;</span>,<br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Println(data)<br><span class="hljs-comment">// 监听配置文件变动</span><br>err = configClient.ListenConfig(vo.ConfigParam&#123;<br>DataId: <span class="hljs-string">&quot;config_pre.yaml&quot;</span>,<br>Group:  <span class="hljs-string">&quot;DEFAULT_GROUP&quot;</span>,<br>OnChange: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(namespace, group, dataId, data <span class="hljs-type">string</span>)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;group:&quot;</span> + group + <span class="hljs-string">&quot;, dataId:&quot;</span> + dataId + <span class="hljs-string">&quot;, data:&quot;</span> + data)<br>&#125;,<br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">select</span> &#123;&#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>NACOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安装 K8s</title>
    <link href="/2022/01/01/K8S/install/"/>
    <url>/2022/01/01/K8S/install/</url>
    
    <content type="html"><![CDATA[<h3 id="kubeadm-安装-K8s">kubeadm 安装 K8s</h3><h3 id="关闭防火墙：">关闭防火墙：</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">systemctl stop firewalld<br><br>systemctl <span class="hljs-built_in">disable</span><span class="hljs-built_in"> firewall</span><br><span class="hljs-built_in"></span><br></code></pre></td></tr></table></figure><h3 id="关闭-selinux：">关闭 selinux：</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">sed -i <span class="hljs-string">&#x27;s/enforcing/disabled/&#x27;</span> <span class="hljs-regexp">/etc/</span>selinux/config <span class="hljs-comment"># 永久</span><br>setenforce <span class="hljs-number">0</span> <span class="hljs-comment"># 临时</span><br></code></pre></td></tr></table></figure><h3 id="关闭-swap：">关闭 swap：</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">swapoff -a <span class="hljs-comment"># 临时</span><br>sed -ri <span class="hljs-string">&#x27;s/.*swap.*/#&amp;/&#x27;</span> <span class="hljs-regexp">/etc/</span>fstab <span class="hljs-comment"># 永久</span><br></code></pre></td></tr></table></figure><h3 id="将桥接的-IPv4-流量传递到-iptables-的链：">将桥接的 IPv4 流量传递到 iptables 的链：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> &gt; /etc/sysctl.d/k8s.conf &lt;&lt; <span class="hljs-string">EOF</span><br><span class="hljs-string">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="hljs-string">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="hljs-string">EOF</span><br>sysctl --system <span class="hljs-comment"># 生效</span><br></code></pre></td></tr></table></figure><h3 id="设置hostname">设置hostname</h3><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">hostnamectl</span> <span class="hljs-built_in">set-hostname</span> <span class="hljs-string">node1</span><br></code></pre></td></tr></table></figure><h3 id="添加host">添加host</h3><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">cat &gt;&gt; /etc/hosts &lt;&lt; EOF<br><span class="hljs-number">192.168.223.132</span> node1<br><span class="hljs-number">192.168.223.133</span> node2<br><span class="hljs-number">192.168.223.134</span> node3<br>EOF<br></code></pre></td></tr></table></figure><h3 id="安装docker">安装docker</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">yum-config-manager --add-repo http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/docker-ce/</span>linux<span class="hljs-regexp">/centos/</span>docker-ce.repo<br></code></pre></td></tr></table></figure><h3 id="安装并启动-docker">安装并启动 docker</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">yum</span> install -y docker-ce-<span class="hljs-number">19</span>.<span class="hljs-number">03</span>.<span class="hljs-number">8</span> docker-ce-cli-<span class="hljs-number">19</span>.<span class="hljs-number">03</span>.<span class="hljs-number">8</span> containerd.io<br><span class="hljs-attribute">systemctl</span> enable docker<br><span class="hljs-attribute">dsystemctl</span> start docker<br><br></code></pre></td></tr></table></figure><h4 id="阿里云docker镜像加速">阿里云docker镜像加速</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">mkdir -p <span class="hljs-regexp">/etc/</span>docker<br>tee <span class="hljs-regexp">/etc/</span>docker/daemon.json &lt;&lt;-<span class="hljs-string">&#x27;EOF&#x27;</span><br>&#123;<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://3p9gqnrv.mirror.aliyuncs.com&quot;</span>]<br>&#125;<br>EOF<br>systemctl daemon-reload<br>systemctl restart docker<br></code></pre></td></tr></table></figure><h3 id="安装k8s、kubelet、kubeadm、kubectl（所有节点）">安装k8s、kubelet、kubeadm、kubectl（所有节点）</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 配置K8S的yum源</span><br>cat &lt;&lt;EOF &gt; <span class="hljs-regexp">/etc/yum</span>.repos.d/kubernetes.repo<br>[kubernetes]<br>name=Kubernetes<br>baseurl=http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/kubernetes/yum</span><span class="hljs-regexp">/repos/</span>kubernetes-el7-x86_64<br>enabled=<span class="hljs-number">1</span><br>gpgcheck=<span class="hljs-number">0</span><br>repo_gpgcheck=<span class="hljs-number">0</span><br>gpgkey=http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/kubernetes/yum</span><span class="hljs-regexp">/doc/yum</span>-key.gpg<br>       http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/kubernetes/yum</span><span class="hljs-regexp">/doc/</span>rpm-package-key.gpg<br>EOF<br><br><span class="hljs-comment"># 卸载旧版本</span><br>yum remove -y kubelet kubeadm kubectl<br><br><span class="hljs-comment"># 安装kubelet、kubeadm、kubectl</span><br>yum install -y kubelet-<span class="hljs-number">1.17</span>.<span class="hljs-number">3</span> kubeadm-<span class="hljs-number">1.17</span>.<span class="hljs-number">3</span> kubectl-<span class="hljs-number">1.17</span>.<span class="hljs-number">3</span><br><br><span class="hljs-comment">#开机启动和重启kubelet</span><br>systemctl enable kubelet &amp;&amp; systemctl start kubelet<br><span class="hljs-comment">##注意, 如果此时查看kubelet的状态, 他会无限重启, 等待接收集群命令, 和初始化。这个是正常的。</span><br><br>kubeadm 初始化master <br> kubeadm init \<br>--apiserver-advertise-address=<span class="hljs-number">192.168</span>.<span class="hljs-number">223.132</span> \<br>--image-repository registry.aliyuncs.com/google_containers \<br>--kubernetes-version v1.<span class="hljs-number">17.3</span> \<br>--service-cidr=<span class="hljs-number">10.96</span>.<span class="hljs-number">0.0</span>/<span class="hljs-number">12</span> \<br>--pod-network-cidr=<span class="hljs-number">10.244</span>.<span class="hljs-number">0.0</span>/<span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta"># worker加入集群</span><br><br><span class="hljs-meta">#1、使用刚才master打印的令牌命令加入</span><br>kubeadm join <span class="hljs-number">172.26</span><span class="hljs-number">.248</span><span class="hljs-number">.150</span>:<span class="hljs-number">6443</span> --<span class="hljs-built_in">token</span> ktnvuj.tgldo613ejg5a3x4 \<br>    --discovery-<span class="hljs-built_in">token</span>-ca-cert-hash sha256:f66c496cf7eb8aa06e1a7cdb9b6be5b013c613cdcf5d1bbd88a6ea19a2b454ec<br><br><span class="hljs-meta">#2、如果超过2小时忘记了令牌, 可以这样做</span><br>kubeadm <span class="hljs-built_in">token</span> <span class="hljs-keyword">create</span> --<span class="hljs-keyword">print</span>-join-command <span class="hljs-meta">#打印新令牌</span><br>kubeadm <span class="hljs-built_in">token</span> <span class="hljs-keyword">create</span> --ttl <span class="hljs-number">0</span> --<span class="hljs-keyword">print</span>-join-command <span class="hljs-meta">#创建个永不过期的令牌</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>K8S</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>K8S yaml</title>
    <link href="/2022/01/01/K8S/yaml/"/>
    <url>/2022/01/01/K8S/yaml/</url>
    
    <content type="html"><![CDATA[<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># yaml格式的pod定义文件完整内容：</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>       <span class="hljs-comment">#必选, 版本号, 例如v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>       <span class="hljs-comment">#必选, Pod</span><br><span class="hljs-attr">metadata:</span>       <span class="hljs-comment">#必选, 元数据</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">string</span>       <span class="hljs-comment">#必选, Pod名称</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">string</span>    <span class="hljs-comment">#必选, Pod所属的命名空间</span><br>  <span class="hljs-attr">labels:</span>      <span class="hljs-comment">#自定义标签</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">string</span>     <span class="hljs-comment">#自定义标签名字</span><br>  <span class="hljs-attr">annotations:</span>       <span class="hljs-comment">#自定义注释列表</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">string</span><br><span class="hljs-attr">spec:</span>         <span class="hljs-comment">#必选, Pod中容器的详细定义</span><br>  <span class="hljs-attr">containers:</span>      <span class="hljs-comment">#必选, Pod中容器列表</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">string</span>     <span class="hljs-comment">#必选, 容器名称</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">string</span>    <span class="hljs-comment">#必选, 容器的镜像名称</span><br>    <span class="hljs-attr">imagePullPolicy:</span> [<span class="hljs-string">Always</span> <span class="hljs-string">|</span> <span class="hljs-string">Never</span> <span class="hljs-string">|</span> <span class="hljs-string">IfNotPresent</span>] <span class="hljs-comment">#获取镜像的策略 Alawys表示下载镜像 IfnotPresent表示优先使用本地镜像, 否则下载镜像, Nerver表示仅使用本地镜像</span><br>    <span class="hljs-attr">command:</span> [<span class="hljs-string">string</span>]    <span class="hljs-comment">#容器的启动命令列表, 如不指定, 使用打包时使用的启动命令</span><br>    <span class="hljs-attr">args:</span> [<span class="hljs-string">string</span>]     <span class="hljs-comment">#容器的启动命令参数列表</span><br>    <span class="hljs-attr">workingDir:</span> <span class="hljs-string">string</span>     <span class="hljs-comment">#容器的工作目录</span><br>    <span class="hljs-attr">volumeMounts:</span>    <span class="hljs-comment">#挂载到容器内部的存储卷配置</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">string</span>     <span class="hljs-comment">#引用pod定义的共享存储卷的名称, 需用volumes[]部分定义的的卷名</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">string</span>    <span class="hljs-comment">#存储卷在容器内mount的绝对路径, 应少于512字符</span><br>      <span class="hljs-attr">readOnly:</span> <span class="hljs-string">boolean</span>    <span class="hljs-comment">#是否为只读模式</span><br>    <span class="hljs-attr">ports:</span>       <span class="hljs-comment">#需要暴露的端口库号列表</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">string</span>     <span class="hljs-comment">#端口号名称</span><br>      <span class="hljs-attr">containerPort:</span> <span class="hljs-string">int</span>   <span class="hljs-comment">#容器需要监听的端口号</span><br>      <span class="hljs-attr">hostPort:</span> <span class="hljs-string">int</span>    <span class="hljs-comment">#容器所在主机需要监听的端口号, 默认与Container相同</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">string</span>     <span class="hljs-comment">#端口协议, 支持TCP和UDP, 默认TCP</span><br>    <span class="hljs-attr">env:</span>       <span class="hljs-comment">#容器运行前需设置的环境变量列表</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">string</span>     <span class="hljs-comment">#环境变量名称</span><br>      <span class="hljs-attr">value:</span> <span class="hljs-string">string</span>    <span class="hljs-comment">#环境变量的值</span><br>    <span class="hljs-attr">resources:</span>       <span class="hljs-comment">#资源限制和请求的设置</span><br>      <span class="hljs-attr">limits:</span>      <span class="hljs-comment">#资源限制的设置</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">string</span>    <span class="hljs-comment">#Cpu的限制, 单位为core数, 将用于docker run --cpu-shares参数</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">string</span>     <span class="hljs-comment">#内存限制, 单位可以为Mib/Gib, 将用于docker run --memory参数</span><br>      <span class="hljs-attr">requests:</span>      <span class="hljs-comment">#资源请求的设置</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">string</span>    <span class="hljs-comment">#Cpu请求, 容器启动的初始可用数量</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">string</span>     <span class="hljs-comment">#内存清楚, 容器启动的初始可用数量</span><br>    <span class="hljs-attr">livenessProbe:</span>     <span class="hljs-comment">#对Pod内个容器健康检查的设置, 当探测无响应几次后将自动重启该容器, 检查方法有exec、httpGet和tcpSocket, 对一个容器只需设置其中一种方法即可</span><br>      <span class="hljs-attr">exec:</span>      <span class="hljs-comment">#对Pod容器内检查方式设置为exec方式</span><br>        <span class="hljs-attr">command:</span> [<span class="hljs-string">string</span>]  <span class="hljs-comment">#exec方式需要制定的命令或脚本</span><br>      <span class="hljs-attr">httpGet:</span>       <span class="hljs-comment">#对Pod内个容器健康检查方法设置为HttpGet, 需要制定Path、port</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">string</span><br>        <span class="hljs-attr">port:</span> <span class="hljs-string">number</span><br>        <span class="hljs-attr">host:</span> <span class="hljs-string">string</span><br>        <span class="hljs-attr">scheme:</span> <span class="hljs-string">string</span><br>        <span class="hljs-attr">HttpHeaders:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">string</span><br>          <span class="hljs-attr">value:</span> <span class="hljs-string">string</span><br>      <span class="hljs-attr">tcpSocket:</span>     <span class="hljs-comment">#对Pod内个容器健康检查方式设置为tcpSocket方式</span><br>         <span class="hljs-attr">port:</span> <span class="hljs-string">number</span><br>       <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">0</span>  <span class="hljs-comment">#容器启动完成后首次探测的时间, 单位为秒</span><br>       <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">0</span>   <span class="hljs-comment">#对容器健康检查探测等待响应的超时时间, 单位秒, 默认1秒</span><br>       <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">0</span>    <span class="hljs-comment">#对容器监控检查的定期探测时间设置, 单位秒, 默认10秒一次</span><br>       <span class="hljs-attr">successThreshold:</span> <span class="hljs-number">0</span><br>       <span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">0</span><br>       <span class="hljs-attr">securityContext:</span><br>         <span class="hljs-string">privileged:false</span><br>    <span class="hljs-attr">restartPolicy:</span> [<span class="hljs-string">Always</span> <span class="hljs-string">|</span> <span class="hljs-string">Never</span> <span class="hljs-string">|</span> <span class="hljs-string">OnFailure</span>]<span class="hljs-comment">#Pod的重启策略, Always表示一旦不管以何种方式终止运行, kubelet都将重启, OnFailure表示只有Pod以非0退出码退出才重启, Nerver表示不再重启该Pod</span><br>    <span class="hljs-attr">nodeSelector:</span> <span class="hljs-string">obeject</span>  <span class="hljs-comment">#设置NodeSelector表示将该Pod调度到包含这个label的node上, 以key：value的格式指定</span><br>    <span class="hljs-attr">imagePullSecrets:</span>    <span class="hljs-comment">#Pull镜像时使用的secret名称, 以key：secretkey格式指定</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">string</span><br>    <span class="hljs-string">hostNetwork:false</span>      <span class="hljs-comment">#是否使用主机网络模式, 默认为false, 如果设置为true, 表示使用宿主机网络</span><br>    <span class="hljs-attr">volumes:</span>       <span class="hljs-comment">#在该pod上定义共享存储卷列表</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">string</span>     <span class="hljs-comment">#共享存储卷名称 （volumes类型有很多种）</span><br>      <span class="hljs-attr">emptyDir:</span> &#123;&#125;     <span class="hljs-comment">#类型为emtyDir的存储卷, 与Pod同生命周期的一个临时目录。为空值</span><br>      <span class="hljs-attr">hostPath:</span> <span class="hljs-string">string</span>     <span class="hljs-comment">#类型为hostPath的存储卷, 表示挂载Pod所在宿主机的目录</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">string</span>     <span class="hljs-comment">#Pod所在宿主机的目录, 将被用于同期中mount的目录</span><br>      <span class="hljs-attr">secret:</span>      <span class="hljs-comment">#类型为secret的存储卷, 挂载集群与定义的secre对象到容器内部</span><br>        <span class="hljs-attr">scretname:</span> <span class="hljs-string">string</span>  <br>        <span class="hljs-attr">items:</span>     <br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">string</span><br>          <span class="hljs-attr">path:</span> <span class="hljs-string">string</span><br>      <span class="hljs-attr">configMap:</span>     <span class="hljs-comment">#类型为configMap的存储卷, 挂载预定义的configMap对象到容器内部</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">string</span><br>        <span class="hljs-attr">items:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">string</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>K8S</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务框架 go-micro 代理 proxy 接受消息值最大修改</title>
    <link href="/2021/08/06/blog/golang/go_micro_MaxCallRecvMsgSize/"/>
    <url>/2021/08/06/blog/golang/go_micro_MaxCallRecvMsgSize/</url>
    
    <content type="html"><![CDATA[<h3 id="center-微服务框架-go-micro-代理-proxy-接受消息值最大修改-center"><center> 微服务框架 go-micro 代理 proxy 接受消息值最大修改 </center></h3><p>keyword: MaxCallRecvMsgSize</p><p>go-micro 框架自带了 proxy 用来代理微服务之间的rpc请求,因为框架内部封装好了 client(本质是服务对服务直接请求) 可以在golang端轻松修改 clientGrpc.MaxRecvMsgSize,clientGrpc.MaxSendMsgSize 来设置请求数据</p><p>go-micro 框架默认服务间最大响应值是4M.</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 启动 proxy</span><br><span class="hljs-built_in">set</span> <span class="hljs-attribute">MICRO_REGISTRY</span>=etcd<br><span class="hljs-built_in">set</span> <span class="hljs-attribute">MICRO_REGISTRY_ADDRESS</span>=127.0.0.1:2379<br>micro proxy<br></code></pre></td></tr></table></figure><p>然而在 micro proxy 中这两个参数是失效的,导致公司C++客户端进行rpc调用的时候不能请求一些大型的数据内容,追了一下源码,发现grpc官方已经把4M固定死,但是还是留了口子让我们通过CallOption改动对应的值</p><p>前置条件:</p><p>所有的 service 必须修改 DefaultMaxMsgSize</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-keyword">import</span> (<br>    ...<br>    serverGrpc <span class="hljs-string">&quot;github.com/micro/go-micro/v2/server/grpc&quot;</span><br>    <br>)<br><br><span class="hljs-keyword">const</span> maxMsgSize <span class="hljs-type">int</span> = <span class="hljs-number">8</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>  &#123;<br>    serverGrpc.DefaultMaxMsgSize = maxMsgSize<br>&#125;<br><br></code></pre></td></tr></table></figure><p>构建proxy</p><p>改动点有两个</p><ol><li><p>init 方法中必须要把 micro server 的 DefaultMaxMsgSize改掉</p></li><li><p>然后就是 Client.Init 去初始化 CallOption</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// proxy.go</span><br><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;github.com/micro/go-micro/v2&quot;</span><br>    <span class="hljs-string">&quot;github.com/micro/go-micro/v2/client&quot;</span><br>    clientGrpc <span class="hljs-string">&quot;github.com/micro/go-micro/v2/client/grpc&quot;</span><br>    serverGrpc <span class="hljs-string">&quot;github.com/micro/go-micro/v2/server/grpc&quot;</span><br>    <span class="hljs-string">&quot;github.com/micro/micro/v2/cmd&quot;</span><br>    <span class="hljs-string">&quot;google.golang.org/grpc&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> maxMsgSize <span class="hljs-type">int</span> = <span class="hljs-number">8</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>  &#123;<br>    serverGrpc.DefaultMaxMsgSize = maxMsgSize<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br><br>    cmd.Init(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(options *micro.Options)</span></span> &#123;<br>        err := options.Client.Init(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(options *client.Options)</span></span> &#123;<br>            clientGrpc.CallOptions(grpc.MaxCallRecvMsgSize(maxMsgSize))(&amp;options.CallOptions)<br>        &#125;)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-built_in">panic</span>(err)<br>        &#125;<br>    &#125;)<br>&#125;<br><br><br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 启动 proxy</span><br><span class="hljs-built_in">set</span> <span class="hljs-attribute">MICRO_REGISTRY</span>=etcd<br><span class="hljs-built_in">set</span> <span class="hljs-attribute">MICRO_REGISTRY_ADDRESS</span>=127.0.0.1:2379<br>go <span class="hljs-built_in">run</span> proxy.go proxy<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>go-micro</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 错误的初始化 Slice, 痛痛痛</title>
    <link href="/2021/07/06/blog/golang/error_init_slice/"/>
    <url>/2021/07/06/blog/golang/error_init_slice/</url>
    
    <content type="html"><![CDATA[<h3 id="center-错误的初始化-Slice-痛痛痛-center"><center>错误的初始化 Slice, 痛痛痛</center></h3><p>先上代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>&#125;<br><br>ns1 := newSlice1(s)<br>ns2 := newSlice2(s)<br><br>fmt.Printf(<span class="hljs-string">&quot;value = %+v, %p \n&quot;</span>, s, s)     <span class="hljs-comment">//value = [A2 B C], 0xc00007a330</span><br>fmt.Printf(<span class="hljs-string">&quot;value = %+v, %p \n&quot;</span>, ns1, ns1) <span class="hljs-comment">//value = [A2], 0xc00007a330</span><br>fmt.Printf(<span class="hljs-string">&quot;value = %+v, %p \n&quot;</span>, ns2, ns2) <span class="hljs-comment">//value = [A2], 0xc00007a330</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newSlice1</span><span class="hljs-params">(s []<span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>ns := s[:<span class="hljs-number">0</span>]<br>ns = <span class="hljs-built_in">append</span>(ns, <span class="hljs-string">&quot;A1&quot;</span>)<br><span class="hljs-keyword">return</span> ns<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newSlice2</span><span class="hljs-params">(s []<span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>ns := s[:<span class="hljs-number">0</span>]<br>ns = <span class="hljs-built_in">append</span>(ns, <span class="hljs-string">&quot;A2&quot;</span>)<br><span class="hljs-keyword">return</span> ns<br>&#125;<br></code></pre></td></tr></table></figure><p>重构旧代码的时候, 发现了一些function里使用类似上面<br><code>ns := s[:0]</code><br>来出创建新的Slice, 就是不想导入包, 或少写一些代码</p><p>本以为还有我没学习到的奇技淫巧, 然而发现只要对这种新创建的切片做修改操作, 所有关联使用的地方都会出现修改</p><p><strong>本质这些创建的切片指向的还是同一片内存空间</strong></p><p>因为项目使用只是对切片做一些过滤, 然后返回出去, 这种问题被自然规避掉了</p>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>发布自己 golang package</title>
    <link href="/2021/04/22/blog/golang/%E5%8F%91%E5%B8%83%E8%87%AA%E5%B7%B1go%E5%8C%85/"/>
    <url>/2021/04/22/blog/golang/%E5%8F%91%E5%B8%83%E8%87%AA%E5%B7%B1go%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h4 id="center-发布自己-golang-package-center"><center>发布自己 golang package</center></h4><p>(1) 代码提交到自己的github项目库 并且上tag</p><p>例如: <code>github.com/maocatooo/thin</code></p>   <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">git</span> tag v0.<span class="hljs-number">0</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">git</span> push origin v0.<span class="hljs-number">0</span>.<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>(2) 告诉golang 代理服务器更新其索引</p><ol><li><p>访问 <a href="https://pkg.go.dev/github.com/maocatooo/thin">https://pkg.go.dev/github.com/maocatooo/thin</a> 提交自己项目链接</p></li><li> <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">set</span> <span class="hljs-attribute">GOPROXY</span>=proxy.golang.org<br>go list -m github.com/maocatooo/thin@v0.0.1<br></code></pre></td></tr></table></figure><p>然而因为代理问题大概率是会超时的,</p><p>解决办法:在浏览器打开 <a href="https://proxy.golang.org/github.com/maocatooo/thin/@v/v0.0.1.info">https://proxy.golang.org/github.com/maocatooo/thin/@v/v0.0.1.info</a>&quot;</p></li></ol><p>(3) 等待一段时间就好</p>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统一些概念</title>
    <link href="/2020/04/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2020/04/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="进程与线程的区别">进程与线程的区别</h3><p>做个简单的比喻：进程=火车, 线程=车厢</p><ul><li>线程在进程下行进（单纯的车厢无法运行）</li><li>一个进程可以包含多个线程（一辆火车可以有多个车厢）</li><li>不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车, 比如站点换乘）</li><li>同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）</li><li>进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）</li><li>进程间不会相互影响, 一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车, 但是如果一列火车上中间的一节车厢着火了, 将影响到所有车厢）</li><li>进程可以拓展到多机, 进程最多适合多核（不同火车可以开在多个轨道上, 同一火车的车厢不能在行进的不同的轨道上）</li><li>进程使用的内存地址（洗手间）可以上锁, 即一个线程使用某些共享内存时, 其他线程必须等它结束, 才能使用这一块内存。（比如火车上的洗手间）－“互斥锁”</li><li>进程使用的内存地址可以限定使用量（比如火车上的餐厅, 最多只允许多少人进入, 如果满了需要在门口等, 等有人出来了才能进去）－“信号量”</li></ul><p>进程是系统进行资源调度和分配的基本单位——》实现操作系统的并发</p><p>线程是cpu调度的基本单位——〉实现进程内部的并发</p><h3 id="同步与互斥">同步与互斥</h3><p>互斥就是线程A访问了一组数据, 线程BCD就不能同时访问这些数据, 直到A停止访问了<br>同步就是ABCD这些线程要约定一个执行的协调顺序。比如D要执行, B和C必须都得做完, 而B和C要开始, A必须先得做完</p><h3 id="死锁产生的必要条件">死锁产生的必要条件</h3><p>产生死锁的的四个条件如下：互请不循<br>1、互斥条件：一个资源每次只能被一个进程使用；<br>2、请求与保持条件：一个进程因请求资源而阻塞时, 对已获得的资源保持不放；<br>3、不剥夺条件：进程已获得的资源, 在没使用完之前, 不能强行剥夺；<br>4、循环等待条件：多个进程之间形成一种互相循环等待资源的关系。<br>并发带来压力, 有的人或有的程序, 会因为承受不住压力而崩溃, 情绪崩溃和程序崩溃没什么两样。当然, 不论是做人还是写程序, 面对问题时, 正确的做法都应是采取策略, 解除死锁</p><h3 id="计算机系统概述">计算机系统概述</h3><p>1、操作系统是什么？</p><p>操作系统是计算机资源的管理者, 比如有处理机管理、存储器管理、文件管理、设备管理</p><p>2、中断与异常？</p><p>中断：也称外中断, 指来自CPU执行指令以外的事件发生, 如设备发出的I/O结束中断, 通常是与当前执行指令无关的事件</p><p>异常：也称内中断, 比如程序地址越界 , 有关。</p><p>3、大内核与微内核区别？</p><p>（联想单体架构和微服务的区别）</p><p>大内核的性能比微内核高</p><p>因为微内核这个模块运行在内核态, 其余模块运行在用户态, 在就导致需要经常内核态和用户态之间进行切换, 导致一定的性能损失</p><h3 id="进程管理">进程管理</h3><p>什么是饥饿, 与死锁有什么差别？</p><p>饥饿：等待时间对进程的推进和响应带来明显的就是进程饥饿</p><p>与死锁的区别？</p><ol><li><p>进入饥饿的进程可以只有1个, 而死锁要大于等于两个</p></li><li><p>饥饿进程可以是就绪状态, 而死锁必须是阻塞状态</p></li></ol><p>Windows 下的内存是如何管理的？</p><p>分页管理</p><p>什么是内存管理？</p><p>内存管理的基本功能就是为待运行的程序分配内存, 并在使用结束后回收这些内存</p><p>分区法是一种简单的内存管理方式, 分为固定分区法、动态分区法<br>固定分区法：一旦分区分好, 分区的个数和大小都不再改变<br>动态分区法：根据作业的内存容量需求, 动态为作业划分一块连续的内存空间(分区)</p><h3 id="一个程序从开始运行到结束的完整过程（四个过程）">一个程序从开始运行到结束的完整过程（四个过程）</h3><p>预处理：条件编译, 头文件包含, 宏替换的处理, 生成.i文件。</p><p>编译：将预处理后的文件转换成汇编语言, 生成.s文件</p><p>汇编：汇编变为目标代码(机器代码)生成.o的文件</p><p>链接：连接目标代码,生成可执行程序</p><h3 id="线程模型">线程模型</h3><p>这里以Linux为例。Linux历史上, 最开始使用的线程是LinuxThreads, 但LinuxThreads有些方面受限于内核的特性, 从而违背了SUSV3 Pthreads标准。即它要根据内核的特性来实现线程, 有些地方没有遵循统一的标准。后来IBM开发了NGPT(Next Generation POSIX Threads), 性能明显优于LinuxThreads, 人们曾把它当作LinuxThreads的继任者。但最后, 又有一个项目NPTL(Native POSIX Threads Library)出来后, 性能更优于NGPT。2002年NGPT项目停止开发, 我们现在用的Linux线程就是NPTL。</p><p>线程的实现曾有3种模型：</p><p>1.多对一(M:1)的用户级线程模型</p><p>2.一对一(1:1)的内核级线程模型</p><p>3.多对多(M:N)的两级线程模型</p><p>上面的x对y(x:y)即x个用户线程对应y个内核调度实体(Kernel Scheduling Entity, 这个是内核分配CPU的对象单位)。</p><p>LinuxThreads和NPTL都是采用一对一的线程模型, NGPT采用的是多对多的线程模型！！！</p>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程和进程</title>
    <link href="/2020/04/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
    <url>/2020/04/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="线程和进程">线程和进程</h2><p>线程和进程的关系：线程是进程的基本执行单元, 一个进程的所有任务都在线程中执行。进程要想执行任务, 必须得有线程, 进程至少要有一条线程</p><ul><li><p>区别：</p><p>地址空间：同一进程的线程共享本进程的地址空间, 而进程之间则是独立的地址空间。</p><p>资源拥有：同一进程内的线程共享本进程的资源如内存、I/O、cpu等, 但是进程之间的资源是独立的</p></li></ul><h3 id="进程间通信的方式有：">进程间通信的方式有：</h3><p>一、管道</p><p>管道, 通常指无名管道, 是 UNIX 系统IPC最古老的形式。</p><p>特点：</p><p>它是半双工的（即数据只能在一个方向上流动）, 具有固定的读端和写端。</p><p>它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）。</p><p>它可以看成是一种特殊的文件, 对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件, 并不属于其他任何文件系统, 并且只存在于内存中。</p><p>二、FIFO</p><p>FIFO, 也称为命名管道, 它是一种文件类型。</p><p>1、特点</p><p>FIFO可以在无关的进程之间交换数据, 与无名管道不同。</p><p>FIFO有路径名与之相关联, 它以一种特殊设备文件形式存在于文件系统中。</p><p>三、消息队列</p><p>消息队列, 是消息的链接表, 存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。</p><p>特点</p><p>消息队列是面向记录的, 其中的消息具有特定的格式以及特定的优先级。</p><p>消息队列独立于发送与接收进程。进程终止时, 消息队列及其内容并不会被删除。</p><p>消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。</p><p>四、信号量</p><p>信号量（semaphore）与已经介绍过的 IPC 结构不同, 它是一个计数器。信号量用于实现进程间的互斥与同步, 而不是用于存储进程间通信数据。</p><p>特点</p><p>信号量用于进程间同步, 若要在进程间传递数据需要结合共享内存。</p><p>信号量基于操作系统的 PV 操作, 程序对信号量的操作都是原子操作。</p><p>每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1, 而且可以加减任意正整数。</p><p>支持信号量组。</p><p>五、共享内存</p><p>共享内存（Shared Memory）, 指两个或多个进程共享一个给定的存储区。</p><p>特点</p><p>共享内存是最快的一种 IPC, 因为进程是直接对内存进行存取。</p><p>因为多个进程可以同时操作, 所以需要进行同步。</p><p>信号量+共享内存通常结合在一起使用, 信号量用来同步对共享内存的访问。</p><p>进程有五种状态：</p><ul><li>创建状态：进程在创建时需要申请一个空白PCB, 向其中填写控制和管理进程的信息, 完成资源分配。如果创建工作无法完成, 比如资源无法满足, 就无法被调度运行, 把此时进程所处状态称为创建状态</li><li>就绪状态：进程已经准备好, 已分配到所需资源, 只要分配到CPU就能够立即运行</li><li>执行状态：进程处于就绪状态被调度后, 进程进入执行状态</li><li>阻塞状态：正在执行的进程由于某些事件（I/O请求, 申请缓存区失败）而暂时无法运行, 进程受到阻塞。在满足请求时进入就绪状态等待系统调用</li><li>终止状态：进程结束, 或出现错误, 或被系统终止, 进入终止状态。无法再执行</li></ul><p>状态转换</p><p><img src="/asset/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/images/1.jpg" alt="状态转换"></p><h3 id="父进程和子进程">父进程和子进程</h3><p>正常情况下, 子进程是通过父进程创建的, 子进程再创建新的子进程。但是子进程的结束和父进程的运行是一个异步过程, 即父进程永远无法预测子进程到底什么时候结束。当一个进程完成它的工作终止之后, 它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态</p><h3 id="僵尸进程和孤儿进程">僵尸进程和孤儿进程</h3><h4 id="僵尸进程">僵尸进程</h4><p>当一个子进程结束运行（一般是调用exit、运行时发生致命错误或收到终止信号所导致）时, 子进程的退出状态（返回值）会回报给操作系统, 系统则以SIGCHLD信号将子进程被结束的事件告知父进程, 此时子进程的进程控制块（PCB）仍驻留在内存中。一般来说, 收到SIGCHLD后, 父进程会使用wait系统调用以获取子进程的退出状态, 然后内核就可以从内存中释放已结束的子进程的PCB；而如若父进程没有这么做的话, 子进程的PCB就会一直驻留在内存中, 也即成为僵尸进程</p><h4 id="孤儿进程">孤儿进程</h4><p>孤儿进程则是指当一个父进程退出, 而它的一个或多个子进程还在运行, 那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养, 并由init进程对它们完成状态收集工作</p>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络 DNS解析过程</title>
    <link href="/2020/04/21/%E7%BD%91%E7%BB%9C/DNS%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/"/>
    <url>/2020/04/21/%E7%BD%91%E7%BB%9C/DNS%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<ol><li>客户端查本地hosts文件</li><li>DNS本地服务缓存 DNS localcache</li><li>DNS server (recursion(递归)请求)</li></ol><ul><li>就是DNS服务器自己负责解析的域：直接查询数据库并返回结果</li><li>不是自己负责的域:<ul><li>server cache:找到返回</li><li>iteration(迭代) 由根找顶级域再找二级域… 完成解析请求</li></ul></li></ul><p>返回的结果：</p><ul><li>肯定答案：确定结果(可以缓存)</li><li>否定答案：不存在查询的键, 所以不存在由键查询的值(也会缓存)</li><li>权威答案：有就是有, 没有就是没有</li><li>非权威答案：肯能server端刚发给客户端没有的结果, 自己就更新了</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络 http https</title>
    <link href="/2020/04/21/%E7%BD%91%E7%BB%9C/http_https/"/>
    <url>/2020/04/21/%E7%BD%91%E7%BB%9C/http_https/</url>
    
    <content type="html"><![CDATA[<h2 id="http">http</h2><p>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）</p><h3 id="http1-0">http1.0</h3><p>HTTP 1.0规定浏览器与服务器只保持短暂的连接, 浏览器的每次请求都需要与服务器建立一个TCP连接, 服务器完成请求处理后立即断开TCP连接, 服务器不跟踪每个客户也不记录过去的请求</p><h3 id="http1-1">http1.1</h3><p>在1.0的基础上变动了以下特性：</p><p><strong>缓存处理</strong> , 在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准, HTTP1.1则引入了更多的缓存控制策略例如Entity tag, If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</p><p><strong>带宽优化及网络连接的使用</strong>, HTTP1.0中, 存在一些浪费带宽的现象, 例如客户端只是需要某个对象的一部分, 而服务器却将整个对象送过来了, 并且不支持断点续传功能, HTTP1.1则在请求头引入了range头域, 它允许只请求资源的某个部分, 即返回码是206（Partial Content）, 这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p><p><strong>错误通知的管理</strong>, 在HTTP1.1中新增了24个错误状态响应码, 如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p><p><strong>Host头处理</strong>, 在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址, 因此, 请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展, 在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers）, 并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域, 且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</p><p><strong>长连接</strong>, HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理, 在一个TCP连接上可以传送多个HTTP请求和响应, 减少了建立和关闭连接的消耗和延迟, 在HTTP1.1中默认开启Connection： keep-alive, 一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点</p><h3 id="http2-0">http2.0</h3><h4 id="什么是SPDY协议">什么是SPDY协议</h4><p>SPDY是Speedy的昵音, 意为“更快”。它是Google开发的基于TCP协议的应用层协议。目标是优化HTTP协议的性能, 通过压缩、多路复用和优先级等技术, 缩短网页的加载时间并提高安全性。SPDY协议的核心思想是尽量减少TCP连接数。SPDY并不是一种用于替代HTTP的协议, 而是对HTTP协议的增强</p><h4 id="HTTP2-0：SPDY的升级版">HTTP2.0：SPDY的升级版</h4><p>HTTP2.0可以说是SPDY的升级版（其实原本也是基于SPDY设计的）, 但是, HTTP2.0 跟 SPDY 仍有不同的地方, 如下：</p><h4 id="HTTP2-0和SPDY的区别：">HTTP2.0和SPDY的区别：</h4><p>HTTP2.0 支持明文 HTTP 传输, 而 SPDY 强制使用 HTTPS</p><p>HTTP2.0 消息头的压缩算法采用 HPACK <a href="http://http2.github.io/http2-spec/compression.html">http://http2.github.io/http2-spec/compression.html</a>, 而非 SPDY 采用的 DEFLATE <a href="http://zh.wikipedia.org/wiki/DEFLATE">http://zh.wikipedia.org/wiki/DEFLATE</a></p><h4 id="HTTP2-0和HTTP1-X相比的新特性">HTTP2.0和HTTP1.X相比的新特性</h4><p><strong>新的二进制格式（Binary Format）</strong>, HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷, 文本的表现形式有多样性, 要做到健壮性考虑的场景必然很多, 二进制则不同, 只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式, 实现方便且健壮。</p><p><strong>多路复用（MultiPlexing）</strong>, 即连接共享, 即每一个request都是是用作连接共享机制的。一个request对应一个id, 这样一个连接上可以有多个request, 每个连接的request可以随机的混杂在一起, 接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</p><p><strong>header压缩</strong>, 如上文中所言, 对前面提到过HTTP1.x的header带有大量信息, 而且每次都要重复发送, HTTP2.0使用encoder来减少需要传输的header大小, 通讯双方各自cache一份header fields表, 既避免了重复header的传输, 又减小了需要传输的大小。</p><p>服务端推送（server push）, 同SPDY一样, HTTP2.0也具有server push功能</p><h3 id="幂等-Idempotence">幂等 Idempotence</h3><p>HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的<strong>副作用</strong></p><p>get 是幂等的,  post不是(不一定是)</p><h2 id="https">https</h2><p>HTTPS 协议是由 HTTP 加上 TLS/SSL 协议构建的可进行加密传输、身份认证的网络协议, 主要通过数字证书、加密算法、非对称密钥等技术完成互联网数据传输加密, 实现互联网传输安全保护。设计目标主要有三个。</p><p>（1）数据保密性：保证数据内容在传输的过程中不会被第三方查看。就像快递员传递包裹一样, 都进行了封装, 别人无法获知里面装了什么</p><p>（2）数据完整性：及时发现被第三方篡改的传输内容。就像快递员虽然不知道包裹里装了什么东西, 但他有可能中途掉包, 数据完整性就是指如果被掉包, 我们能轻松发现并拒收</p><p>（3）身份校验安全性：保证数据到达用户期望的目的地。就像我们邮寄包裹时, 虽然是一个封装好的未掉包的包裹, 但必须确定这个包裹不会送错地方, 通过身份校验来确保送对了地方</p><h4 id="双向的身份认证">双向的身份认证</h4><ul><li><p>客户端和服务端在传输数据之前,会通过基于证书对双方进行身份认证 。具体过程如下 :</p></li><li><p>客户端发起 SSL 握手消息给服务端要求连接。</p></li><li><p>服务端将证书发送给客户端。</p></li><li><p>客户端检查服务端证书, 确认是否由自己信任的证书签发机构签发。 如果不是, 将是否继续通讯的决定权交给用户选择 ( 注意, 这里将是一个安全缺陷 )。如果检查无误或者用户选择继续, 则客户端认可服务端的身份。</p></li><li><p>服务端要求客户端发送证书, 并检查是否通过验证。失败则关闭连接, 认证成功则从客户端证书中获得客户端的公钥, 一般为1024位或者 2048位。到此, 服务器客户端双方的身份认证结束, 双方确保身份都是真实可靠的</p></li></ul><h3 id="cookie和session">cookie和session</h3><table><thead><tr><th></th><th>Cookie</th><th>Session</th></tr></thead><tbody><tr><td>储存位置</td><td>客户端</td><td>服务器端</td></tr><tr><td>目的</td><td>跟踪会话, 也可以保存用户偏好设置或者保存用户名密码等</td><td>跟踪会话</td></tr><tr><td>安全性</td><td>不安全</td><td>安全</td></tr></tbody></table><p>session技术是要使用到cookie的, 之所以出现session技术, 主要是为了安全</p><h3 id="GET和POST">GET和POST</h3><ul><li>url可见性<ul><li>get, 参数url可见</li><li>post, url参数不可见</li></ul></li><li>数据传输上<ul><li>get 通过拼接url进行传递参数；</li><li>post 通过body体传输参数</li></ul></li><li>缓存性<ul><li>get请求是可以缓存的</li><li>post请求不可以缓存</li></ul></li><li>传输数据的大小<ul><li>get一般传输数据大小不超过2k-4k（根据浏览器不同, 限制不一样, 但相差不大）</li><li>post请求传输数据的大小不限制情况下可以无限大</li></ul></li><li>安全性<ul><li>这个也是最不好分析的, 原则上post肯定要比get安全, 毕竟传输参数时url不可见, 但也挡不住部分人闲的没事在那抓包玩。安全性个人觉得是没多大区别的, 防君子不防小人就是这个道理。对传递的参数进行加密, 其实都一样</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络 TCP UDP</title>
    <link href="/2020/04/21/%E7%BD%91%E7%BB%9C/tcp_udp/"/>
    <url>/2020/04/21/%E7%BD%91%E7%BB%9C/tcp_udp/</url>
    
    <content type="html"><![CDATA[<h3 id="TCP三次握手">TCP三次握手</h3><ol><li><p>第一次握手（SYN）：客户端向服务器发送一个SYN（同步）请求，请求建立连接。此时客户端处于SYN_SEND状态。</p></li><li><p>第二次握手（SYN+ACK）：服务器接收到客户端的SYN请求后，向客户端发送一个SYN+ACK（同步+确认）响应，表示已经收到了客户端的请求，并准备好建立连接。此时服务器处于SYN_RECV状态。</p></li><li><p>第三次握手（ACK）：客户端接收到服务器的SYN+ACK响应后，向服务器发送一个ACK（确认）响应，表示已经收到了服务器的确认，并准备好传输数据。此时客户端处于ESTABLISHED状态，服务器也处于ESTABLISHED状态，表示连接已经建立。</p></li></ol><p>建立连接的时候, 发送的包都不包含任何数据, 建立连接后才发送数据, 理想状态下, TCP一旦创建, 在通信双方中的任何一方主动关闭连接之前, TCP都会一直连接下去</p><p>优点：</p><ol><li><p>可以建立可靠连接：确保客户端和服务端是连接可靠的</p></li><li><p>避免资源浪费：可以避免无效连接导致的资源浪费</p></li><li><p>安全性高：只有在建立连接后才能传输数据</p></li></ol><p>缺点：</p><ol><li><p>建立连接速度慢：需要3次确认才能建立连接</p></li><li><p>占用资源：3次握手需要占用客户端和服务端资源，如带宽，cpu等</p></li><li><p>可能被攻击：握手过程中可能会被利用进行攻击，例如SYN洪泛攻击，SYN泄露攻击等，这会导致服务端和客户端无法正常连接，影响网络的正常运行</p></li></ol><h4 id="为什么是三次">为什么是三次</h4><p>TCP 协议的作用是, 保证数据通信的完整性和可靠性, 防止丢包</p><p>TCP作为一种可靠传输控制协议, 其核心思想：既要保证数据可靠传输, 又要提高传输的效率, 而用三次恰恰可以满足以上两方面的需求</p><h4 id="为什么不是两次">为什么不是两次</h4><p>如果只是两次握手, 至多只有连接发起方的起始序列号能被确认, 另一方选择的序列号则得不到确认</p><h4 id="tcp如何保证可靠传输">tcp如何保证可靠传输</h4><p>TCP主要提供了一下几种安全机制来保证数据的安全性和可靠性</p><ol><li><p>检验和</p><p>TCP协议在发送数据前会对数据进行校验和计算，生成一个校验和，将这个校验和附加在数据包的头部。接收方在接收到数据包后，也会计算校验和，然后将计算得到的校验和与接收到的校验和进行比较，如果两者不一致，则说明数据可能已经被破坏或者发生了错误，接收方会丢弃这个数据包并发送重传请求。通过这种方式，TCP协议可以保证数据的完整性和可靠性</p></li><li><p>序列号/确认应答</p><p>TCP协议会为每个数据包分配一个唯一的序列号，接收方收到数据后，会发送一个确认应答ACK，以通知发送方数据已经正确接收。如果发送方没有收到确认应答ACK，则会重发数据包，直到收到确认应答ACK为止</p></li><li><p>超时重传</p><p>如果发送方没有收到确认应答ACK，则会定时重发数据包，直到收到确认应答ACK为止</p></li><li><p>滑动窗口控制(流量控制)</p><p>TCP协议在发送数据时，会根据接收方的接收能力设置一个滑动窗口大小。发送方在发送数据时，需要等待接收方的确认应答，确认接收到了数据包并提供了下一个期望接收的序列号，才能继续发送下一个数据包。通过这种机制，可以确保接收方可以处理自己能够处理的数据包，并且可以避免数据包的丢失或者超时等问题</p></li><li><p>拥塞控制</p><p>TCP协议通过拥塞控制机制来避免网络拥塞，保证网络的可靠性和公平性。发送方会根据网络的拥塞情况来调整发送速度，避免造成网络拥塞</p></li></ol><h3 id="四次挥手">四次挥手</h3><ol><li>由客户端向服务器发送FIN报文, 请求断开连接, 序号为x。此时TCP数据包的标志位为FIN。</li><li>服务器向客户端发送ACK报文, 表示收到了客户端发送的断开连接请求的数据包, 序号为y, 确认序号为x+1。此时TCP数据包的标志位ACK被设置为1</li><li>服务器向客户端发送FIN包, 表示服务器向客户端发送结束请求包, 序号为y, 确认序号为x+1</li><li>由客户端向服务器发送ACK报文, 表示收到服务器的结束请求包, 到这里所有流程走完, 服务器与客户端, 正式断开连接, TCP数据包的序号为x+1, 确认号为y+1</li></ol><p><img src="/asset/%E7%BD%91%E7%BB%9C/images/1.png" alt="123"><br>TIME_WAIT ：TCP 四次握手结束后, 连接双方都不再交换消息, 但主动关闭的一方保持这个连接在一段时间（2MSL两个最大报文生命周期时间）内不可用。</p><p>原因：</p><p>确保最后一个确认报文能够到达（如果B没收到A发送来的确认报文, 那么就会重新发送连接释放请求报文, A等待一段时间就是为了处理这种情况的发生）<br>避免新旧链接混淆。（等待2MSL可以让本连接持续时间内所产生的所有报文都从网络中消失, 使得下一个新的连接请求不会出现旧的连接请求报文）</p><p>优点:</p><ol><li><p>可以防止旧连接数据包被错误地认为是新连接的数据包，从而保证连接的可靠性。</p></li><li><p>可以确保在TCP连接关闭后，双方的所有数据包都被完全传输，防止数据的丢失和混乱。</p></li><li><p>可以确保连接被彻底关闭，避免出现类似于半开连接的情况，从而保证网络的稳定性</p></li></ol><p>缺点：</p><ol><li><p>TIME_WAIT状态会占用连接资源，降低系统的性能和吞吐量。</p></li><li><p>如果同时打开的TCP连接数很多，TIME_WAIT状态的连接会占用大量的连接资源，从而导致连接池耗尽和连接的延迟。</p></li><li><p>TIME_WAIT状态的时长较长（通常为2MSL），可能会对系统的可用性和响应时间造成影响。</p></li></ol><h3 id="TCP-Keepalive">TCP Keepalive</h3><p>TCP Keepalive是一种TCP/IP协议中的机制，它用于检测连接是否处于活动状态。在TCP连接空闲一段时间后，如果没有数据包传输，则Keepalive机制会定期向对端发送一个空的ACK数据包，以检测连接是否仍然处于活动状态。如果对端未能及时响应，TCP会在一定时间后关闭连接，以避免无用的连接占用系统资源</p><h3 id="UDP">UDP</h3><p>面向无连接的传输层协议，它不保证数据传输的可靠性，也不保证数据报文的顺序。UDP主要用于音视频流媒体、在线游戏等对实时性要求较高的应用场景</p><h4 id="特点">特点</h4><p>无连接：UDP不像TCP那样需要在建立连接之后再传输数据，因此可以更快地传输数据。</p><p>不可靠：UDP不保证数据的可靠性，因此在数据传输过程中可能会发生丢包、重复、错误等问题。</p><p>简单：UDP协议的头部很短，只有8个字节，相比之下TCP协议的头部就要复杂得多</p><h4 id="tpc-和-udp-的区别">tpc 和 udp 的区别?</h4><ol><li><p>连接性：TCP是一种面向连接的协议，而UDP则是无连接的。在TCP协议中，发送方和接收方必须先建立连接，然后才能进行数据传输。而在UDP协议中，发送方直接将数据报发送到接收方，不需要先建立连接。</p></li><li><p>可靠性：TCP是一种可靠性较高的协议，它通过序号、确认应答、重传等机制来确保数据传输的可靠性。而UDP协议则是不可靠的，它不保证数据传输的可靠性，也不保证数据报文的顺序。</p></li><li><p>传输效率：由于TCP协议需要建立连接、保证可靠性等机制，因此传输效率相对较低。而UDP协议则没有这些机制，传输效率相对较高。</p></li><li><p>数据大小：TCP协议没有数据大小的限制，而UDP协议则有一个64K的限制。因此，当需要传输较大的数据时，应该使用TCP协议。</p></li><li><p>应用场景：由于TCP协议具有可靠性较高、传输效率较低的特点，适合于传输重要数据、文件下载等需要保证数据可靠性的应用场景。而UDP协议则适合于实时性要求高、数据传输量较小的应用，如在线游戏、语音通话、视频直播等</p></li><li><p>TCP的逻辑通信信道是全双工的可靠信道, UDP则是不可靠信道</p></li></ol><h3 id="OSI-七层协议">OSI 七层协议</h3><ol><li>应用层(数据): 确定进程之间通信的性质以满足用户需要以及提供网络与用户应用</li><li>表示层(数据): 主要解决拥护信息的语法表示问题, 如加密解密</li><li>会话层(数据): 提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制, 如服务器验证用户登录便是由会话层完成的</li><li>运输层(段): 实现网络不同主机上用户进程之间的数据通信, 可靠与不可靠的传输, 传输层的错误检测, 流量控制等</li><li>网络层(包): 提供逻辑地址（IP）、选路, 数据从源端到目的端的传输</li><li>数据链路层(帧): 将上层数据封装成帧, 用MAC地址访问媒介, 错误检测与修正</li><li>物理层（比特流）：设备之间比特流的传输, 物理接口, 电气特性等</li></ol><h3 id="TCP-IP-四层协议">TCP/IP 四层协议</h3><ol><li>应用层（TELNET、FTP、SMTP、HTTP）</li><li>运输层（TCP、UDP）</li><li>网际层（IP、ICMP）</li><li>网络接口层（PPP）</li></ol><h3 id="socket">socket</h3><p>Socket是什么</p><p>Socket是应用层与TCP/IP协议族通信的中间软件抽象层, 它是一组接口。在设计模式中, Socket其实就是一个门面模式, 它把复杂的TCP/IP协议族隐藏在Socket接口后面, 对用户来说, 一组简单的接口就是全部, 让Socket去组织数据, 以符合指定的协议</p><p><img src="/asset/%E7%BD%91%E7%BB%9C/images/2.png" alt="socket"></p><p>Socket=Ip address+ TCP/UDP + port</p>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络 浏览器输入url的全过程</title>
    <link href="/2020/04/21/%E7%BD%91%E7%BB%9C/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/"/>
    <url>/2020/04/21/%E7%BD%91%E7%BB%9C/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="浏览器输入url的全过程">浏览器输入url的全过程</h3><p><img src=".//image/3.jpg" alt=""></p><ol><li>DNS 域名解析</li><li>建立 TCP 连接</li><li>发送 HTTP 请求</li><li>服务器处理请求</li><li>服务器返回响应结果</li><li>关闭 TCP 连接</li><li>浏览器解析 HTML</li><li>浏览器渲染布局</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL InnoDB</title>
    <link href="/2020/04/20/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/InnoDB/"/>
    <url>/2020/04/20/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/InnoDB/</url>
    
    <content type="html"><![CDATA[<h3 id="行锁">行锁</h3><p>InnoDB 的行锁模式她丝旦实现了以下两种类型的行锁</p><p>共享锁（ S ) ：又称为读锁, 简称 S 锁, 共享锁就是多个事务对于同一数据可以共享一把锁, 都能访问到数据, 但是只能读不能修改</p><p>排他锁（ X ) ：又称为写锁, 简称 X 锁, 排他锁就是不能与其他锁并存, 如一个事务获取了一个数据行的排他锁, 其他事务就不能再获取该行的其他锁, 包括共享锁和排他锁, 但是获取排他锁的事务是可以就行读取和修改</p><p>对于 UPDATE 、DELETE 和 INSERT 语句, InnoDB会自动给涉及数据加排他锁（ x ) ;</p><p>对于普通 SELECT 语句, InnoDB 不会加任何锁,</p><p>显示添加锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">LOCK <span class="hljs-keyword">IN</span> SHARE MODE; # 共享锁 S<br><br><span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>; # 排他锁 X<br><br><br></code></pre></td></tr></table></figure><h3 id="行锁升级为表锁">行锁升级为表锁</h3><p>WHERE 条件后面没有使用索引, 或者索引失效, 行锁会升级为表锁</p><h3 id="间隙锁">间隙锁</h3><p>当使用范围条件时, 而不是使用相等条件检索数据, 并请求共享或排它锁时, InnoDB会给符合条件的已有数据加锁, 对于键值在条件范围内但不存在的记录, 叫做 “间隙(GAP)”, InnoDB 也会对这个 “间隙” 加锁, 这种锁机制叫间隙锁(Next-Key锁)</p><h3 id="行锁争用情况查看">行锁争用情况查看</h3><pre><code class="hljs">show status like 'innodb_row_lock_%';   </code></pre><p><img src="/asset/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/images/5.png" alt="行锁争用情况查看"></p><p>Innodb_row_lock_current_waits:当前正在等待锁定的数量<br>Innodb_row_lock_time:从系统启动到现在锁定总时间长度<br>Innodb_row_lock_time_avg: 每次等待所花平均时长<br>Innodb_row_lock_time_max:从系统启动到现在等待最长的一次时间<br>Innodb_row_lock_waits:系统启动到现在总共等待次数</p><p>总结：<br>尽量使用索引来检索数据, 避免行锁升级为表锁<br>合理设计索引, 尽量减少锁的使用范围<br>尽可能减少索引条件, 以及索引范围, 避免间隙锁<br>尽量控制事务大小, 减少锁定资源量和时间长度<br>尽可能使用低级别的事务隔离</p>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL MyISAM</title>
    <link href="/2020/04/20/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/MyISAM/"/>
    <url>/2020/04/20/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/MyISAM/</url>
    
    <content type="html"><![CDATA[<h3 id="InnoDB-和-MyISAM-的锁">InnoDB 和 MyISAM 的锁</h3><p>MyISAM 只支持表锁</p><p>MyISAM 在 SELECT 的时候会自动给表加上读锁, 在执行 UPDATE, DELETE, INSERT 的时候会自动给涉及的表加上写锁, 在操作完成是会释放锁。</p><h4 id="当前会话-线程-对表加上读锁-必须解锁后才能操作其他表-对其他会话无影响">当前会话(线程)对表加上读锁, 必须解锁后才能操作其他表, 对其他会话无影响</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><br>对 MyISAM 显示加锁<br><br># 读锁<br>lock <span class="hljs-keyword">table</span> table_bane read;<br><br># 写锁<br>lock <span class="hljs-keyword">table</span> table_name write;<br><br># 解锁<br>unlock tables;<br><br></code></pre></td></tr></table></figure><p>读锁会阻塞写操作, 但是不会阻塞读操作, 写锁, 读写操作都会阻塞</p><p>查看锁的争用情况</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">open</span> tables;<br></code></pre></td></tr></table></figure><p>In_use： 表的使用次数</p><p>Name_locked: 表名锁定,  用于取消表获取对表进行重命名等操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> status <span class="hljs-keyword">like</span> &quot;Tabke_lock%&quot;;<br></code></pre></td></tr></table></figure><p>Table_locks_immediate : 指的是能够立即获得表锁的次数, 每立即获得锁, 便+1</p><p>Table_locks_waited ：指的是不能够立即获得表锁的次数, 每等待一次, 便+1,  值越高说明争抢情况严重</p><p>MyISAM 适合大量读操作</p>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 事务</title>
    <link href="/2020/04/20/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/%E4%BA%8B%E5%8A%A1/"/>
    <url>/2020/04/20/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="事务">事务</h3><p>MySQL 事务主要用于处理操作量大, 复杂度高的数据。比如说, 在人员管理系统中, 你删除一个人员, 你既需要删除人员的基本资料, 也要删除和该人员相关的信息, 如信箱, 文章等等, 这样, 这些数据库操作语句就构成一个事务！</p><p>在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。</p><p>事务处理可以用来维护数据库的完整性, 保证成批的 SQL 语句要么全部执行, 要么全部不执行。</p><p>事务用来管理 insert,update,delete 语句</p><p>一般来说, 事务是必须满足4个条件（ACID）：</p><ul><li>原子性（Atomicity, 或称不可分割性）、</li><li>一致性（Consistency）、</li><li>隔离性（Isolation, 又称独立性）、</li><li>持久性（Durability）。</li></ul><p>原子性：一个事务（transaction）中的所有操作, 要么全部完成, 要么全部不完成, 不会结束在中间某个环节。事务在执行过程中发生错误, 会被回滚（Rollback）到事务开始前的状态, 就像这个事务从来没有执行过一样。</p><p>一致性：在事务开始之前和事务结束以后, 数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则, 这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p><p>隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力, 隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别, 包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</p><p>持久性：事务处理结束后, 对数据的修改就是永久的, 即便系统故障也不会丢失。</p><p><img src="/asset/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/images/2.png" alt="事务"></p><h3 id="并发事务带来的问题">并发事务带来的问题</h3><p><img src="/asset/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/images/3.png" alt="并发事务带来的问题"></p><h3 id="事务隔离级别">事务隔离级别</h3><p><img src="/asset/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/images/4.png" alt="并发事务带来的问题"></p><p>Read uncommitted 读未提交</p><p>Read committed   读已提交</p><p>Repeatable read  可重复读</p><p>Serializable     串行化</p><p>InnoDB 默认的隔离级别是 Repeatable read;</p><p>查看事务隔离级别</p><pre><code class="hljs">show variables like &quot;tx_isolation&quot;;</code></pre><p>mysql 版本 &gt;= 8.0</p><pre><code class="hljs">select @@transaction_isolation;set session transaction isolation level serializable;</code></pre><h3 id="事务隔离多版本并发控制-MVCC">事务隔离多版本并发控制 MVCC</h3><p>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能, 用更好的方式去处理读-写冲突, 做到即使有读写冲突时, 也能做到不加锁, 非阻塞并发读</p><ul><li><p>快照读</p><p>像不加锁的select操作就是快照读, 即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别, 串行级别下的快照读会退化成当前读；之所以出现快照读的情况, 是基于提高并发性能的考虑, 快照读的实现是基于多版本并发控制, 即MVCC,可以认为MVCC是行锁的一个变种, 但它在很多情况下, 避免了加锁操作, 降低了开销；既然是基于多版本, 即快照读可能读到的并不一定是数据的最新版本, 而有可能是之前的历史版本</p></li></ul><p>说白了MVCC就是为了实现读-写冲突不加锁, 而这个读指的就是快照读, 而非当前读, 当前读实际上是一种加锁的操作, 是悲观锁的实现</p><p>在Mysql的InnoDB引擎中就是指在已提交读(READ COMMITTD)和可重复读(REPEATABLE READ)这两种隔离级别下的事务对于SELECT操作会访问版本链中的记录的过程。</p><p>这就使得别的事务可以修改这条记录, 反正每次修改都会在版本链中记录。SELECT可以去版本链中拿记录, 这就实现了读-写, 写-读的并发执行, 提升了系统的性能</p><h4 id="版本链">版本链</h4><p>在InnoDB引擎表中, 它的聚簇索引记录中有两个必要的隐藏列：</p><p>trx_id</p><p>这个id用来存储的每次对某条聚簇索引记录进行修改的时候的事务id。</p><p>roll_pointer</p><p>每次对哪条聚簇索引记录有修改的时候, 都会把老版本写入undo日志中。这个roll_pointer就是存了一个指针, 它指向这条聚簇索引记录的上一个版本的位置, 通过它来获得上一个版本的记录信息。(注意插入操作的undo日志没有这个属性, 因为它没有老版本)</p>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL MyISAM</title>
    <link href="/2020/04/20/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/json/"/>
    <url>/2020/04/20/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/json/</url>
    
    <content type="html"><![CDATA[<p>JSON数据在不同字段的处理方式：</p><table><thead><tr><th></th><th>大小</th><th>字符集</th><th>校验</th><th>索引</th><th>备注</th></tr></thead><tbody><tr><td>varchar(N)</td><td>N</td><td>表的字符集</td><td>长度限制,字符集,排序规则</td><td>普通索引，唯一索引</td><td>表总和不能超过65535个字符(除去text,JSON, blob类型)</td></tr><tr><td>text</td><td>65535个字符</td><td>表的字符集</td><td>长度限制,字符集,排序规则</td><td>普通索引,全文索引</td><td></td></tr><tr><td>JSON</td><td>64MB(默认, 可修改)</td><td>utf8mb4</td><td>大小,字符集的校验,深度限制(100层),JSON格式校验</td><td>利用虚拟列提取JSON字段作为索引,多值索引(类似普通索引)</td><td></td></tr></tbody></table><p>！！！注意NULL和JSON的null值不同，NULL表示字段值为空，JSON的null值表示字段值是一个空对象</p><h3 id="基础：">基础：</h3><ol><li>插入</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `tt1` (`id`, `varchar1`, `JSON1`, `text1`) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;&#123;\&quot;a\&quot;:\&quot;GXjc0C4hOU\&quot;,\&quot;b\&quot;:5262145246&#125;&#x27;</span>, <span class="hljs-string">&#x27;&#123;\&quot;a\&quot;: \&quot;GXjc0C4hOU\&quot;, \&quot;b\&quot;: 5262145246&#125;&#x27;</span>, <span class="hljs-string">&#x27;&#123;\&quot;a\&quot;:\&quot;GXjc0C4hOU\&quot;,\&quot;b\&quot;:5262145246&#125;&#x27;</span>);<br></code></pre></td></tr></table></figure><p>可以理解为插入的数据实际上是JSON字符串，在插入时会自动解析为JSON对象，然后存储到JSON字段中。</p><ol start="2"><li>修改</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 直接修改JSON字段<br><span class="hljs-keyword">UPDATE</span> `tt1` <span class="hljs-keyword">SET</span> `JSON1` <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;&#123;\&quot;a\&quot;: \&quot;GXjc0C4hOU\&quot;, \&quot;b\&quot;: 5262145246&#125;&#x27;</span> <span class="hljs-keyword">WHERE</span> `id` <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br># 直接修改JSON字段的某个值<br><span class="hljs-keyword">UPDATE</span> `tt1` <span class="hljs-keyword">SET</span> `JSON1` <span class="hljs-operator">=</span> JSON_SET(JSON1, <span class="hljs-string">&#x27;$.b&#x27;</span>, <span class="hljs-number">31</span>) <span class="hljs-keyword">WHERE</span> `id` <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br># 直接修改JSON数组<br><span class="hljs-keyword">UPDATE</span> `tt1` <span class="hljs-keyword">SET</span> `JSON_arr` <span class="hljs-operator">=</span> JSON_SET(JSON_arr, <span class="hljs-string">&#x27;$[0]&#x27;</span>, &quot;3&quot;) <span class="hljs-keyword">WHERE</span> `id` <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br># 嵌套修改<br><span class="hljs-keyword">UPDATE</span> `tt1` <span class="hljs-keyword">SET</span> `text1` <span class="hljs-operator">=</span> JSON_SET(text1, <span class="hljs-string">&#x27;$.c.d&#x27;</span>, <span class="hljs-number">31</span>) <span class="hljs-keyword">WHERE</span> `id` <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><ol start="3"><li>查询(！！！使用JSON函数作为查询条件会走全表扫描)</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> JSON_UNQUOTE(JSON_EXTRACT(JSON1, &quot;$.a&quot;)) <span class="hljs-keyword">as</span> JSON1  <span class="hljs-keyword">FROM</span> `tt1` <span class="hljs-keyword">WHERE</span> JSON_UNQUOTE(JSON_EXTRACT(JSON1, &quot;$.a&quot;)) <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;123&#x27;</span> ;<br></code></pre></td></tr></table></figure><h3 id="常用JSON函数：">常用JSON函数：</h3><pre><code class="hljs">- JSON_EXTRACT(json_column, path)：从json_column中提取path指定的JSON对象，返回JSON对象。- JSON_UNQUOTE(json_column)：将json_column中的所有字符串类型的值都转换为普通字符串。- JSON_VALUE(json_column, path)：从json_column中提取path指定的JSON对象的值，返回JSON对象的值。- JSON_SET(json_column, path, value)：在json_column中设置path指定的JSON对象的值为value，返回修改后的json_column。- JSON_REMOVE(json_column, path)：在json_column中删除path指定的JSON对象，返回修改后的json_column。- JSON_MERGE_PRESERVE(json_column1, json_column2)：将json_column2合并到json_column1中，如果json_column1中有相同的key，则覆盖json_column1中的值。- JSON_MERGE_PATCH(json_column1, json_column2)：将json_column2合并到json_column1中，如果json_column1中有相同的key，则保留json_column1中的值。- JSON_QUERY(json_column, path)：从json_column中提取path指定的JSON对象，返回JSON对象。- JSON_LENGTH(json_column)：返回json_column的长度。- JSON_TYPE(json_column)：返回json_column的类型。- JSON_VALID(json_column)：判断json_column是否是一个有效的JSON字符串。- JSON_ARRAY_LENGTH(json_column)：返回json_column的数组长度。- JSON_OVERLAPS(json_column1, json_column2)：判断json_column1和json_column2是否有交集。、- JSON_CONTAINS(json_column1, json_column2)：判断json_column1是否包含json_column2。</code></pre><h3 id="性能：">性能：</h3><pre><code class="hljs">测试环境： 1000W条数据CREATE TABLE `tt1` (`id` int NOT NULL AUTO_INCREMENT,`varchar1` varchar(2047) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_as_cs DEFAULT NULL,`JSON1` JSON DEFAULT NULL,`text1` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_as_cs,`JSON_arr` JSON DEFAULT NULL,PRIMARY KEY (`id`)) ENGINE=InnoDB  DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_as_cs;SET profiling = 1;SELECT JSON_UNQUOTE(JSON_EXTRACT(varchar1, '$.a') ) as varchar1  FROM `tt1` ;SELECT JSON_UNQUOTE(JSON_EXTRACT(JSON1, &quot;$.a&quot;)) as JSON1  FROM `tt1` ;SELECT JSON_UNQUOTE(JSON_EXTRACT(text1, &quot;$.a&quot;)) as text1  FROM `tt1` ;SHOW PROFILES;</code></pre><p><img src="/asset/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/images/json1.png" alt="执行速度"></p><p>JSON耗时比其他类型少, MYSQL对JSON字段有单独优化,因为在插入得时候已经解析为JSON对象了,其他类型需要额外转换</p><h3 id="JSON-索引">JSON-索引</h3><p>JSON字段创建索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> tt1 <span class="hljs-keyword">add</span> index idx_ttt_JSON1_a( (<span class="hljs-built_in">cast</span>(JSON_UNQUOTE(JSON_EXTRACT(JSON1, &quot;$.a&quot;)) <span class="hljs-keyword">as</span> <span class="hljs-type">char</span>(<span class="hljs-number">255</span>) )) );<br></code></pre></td></tr></table></figure><p>使用索引查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> JSON_UNQUOTE(JSON_EXTRACT(JSON1, &quot;$.a&quot;)) <span class="hljs-keyword">as</span> JSON1  <span class="hljs-keyword">FROM</span> `tt2` <span class="hljs-keyword">WHERE</span> (<span class="hljs-built_in">cast</span>(JSON_UNQUOTE(JSON_EXTRACT(JSON1, &quot;$.a&quot;)) <span class="hljs-keyword">as</span> <span class="hljs-type">char</span>(<span class="hljs-number">255</span>) ))<span class="hljs-operator">=</span><span class="hljs-string">&#x27;123&#x27;</span>;<br></code></pre></td></tr></table></figure><p>效果：<br><img src="/asset/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/images/json2.png" alt="执行速度"></p><p>数组形式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> tt1 <span class="hljs-keyword">add</span> index idx_ttt_JSON1_a( (<span class="hljs-built_in">cast</span>(JSON_UNQUOTE(JSON_EXTRACT(JSON1, &quot;$.a&quot;)) <span class="hljs-keyword">as</span> <span class="hljs-type">char</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">ARRAY</span> )) );<br></code></pre></td></tr></table></figure><p>查询，提供了三个查询函数</p><p>MEMBER OF() 数组中是否存在某一值（如果是唯一匹配查询建议用这种否则选下面两种）</p><p>JSON_CONTAINS() 数组中是否包含某些值，交集(必须都包含，此处注意mysql版本必须是8.024以上否则使用可能会失效)</p><p>JSON_OVERLAPS() 数组中是否包含某些值，并集(只要包含一个就行省的用JSON_CONTAINS一直OR)</p><h3 id="优缺点">优缺点</h3><p>优点：</p><ol><li>灵活的数据结构：JSON字段可以存储复杂的数据结构，如数组、对象、字符串等。</li><li>存储空间：JSON字段的存储空间比其他类型更大。</li><li>提供了JSON的校验功能：JSON字段可以对数据结构进行校验，确保数据符合要求。</li></ol><p>缺点：</p><ol><li>性能：JSON字段的性能比其他类型更差,尤其是在查询时。</li><li>结构可能会混乱,如字符串和数字可以混合,需要插入的人保证结构一致性。如：row1.JSON_field = {“a”: “123”} row2.JSON_field = {“a”: 456}</li><li>数据更新不方便：JSON字段的更新比较麻烦,需要先解析JSON,然后再更新。(如之前发生的手机号转换,zipcode转换地址等)</li></ol><h3 id="使用建议">使用建议??</h3><p>作为一些不必要查询，修改的复杂数据结构，使用JSON，可以存储更多的内容,也可以避免使用新的关联表来存储数据,减少数据库的耦合性,提高开发效率</p><p>但是一涉及到数据的查询和修改，都需要注意JSON的性能问题, 没有索引使用JSON相关的处理函数会导致全表扫描数据,导致性能下降,而使用了JSON相关的索引,则需要维护数据的的结构和类型，避免出现数据类型不一致的情况</p>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 常用技巧</title>
    <link href="/2020/04/20/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <url>/2020/04/20/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<p>编写顺序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span><br>    <span class="hljs-operator">&lt;</span><span class="hljs-keyword">select</span> list<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">FROM</span><br>    <span class="hljs-operator">&lt;</span><span class="hljs-keyword">left</span> <span class="hljs-keyword">table</span><span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span><span class="hljs-keyword">join</span> type<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">JOIN</span><br>    <span class="hljs-operator">&lt;</span>right_table<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>join_condition<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">WHERE</span><br>    <span class="hljs-operator">&lt;</span>where_condition<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <br>    <span class="hljs-operator">&lt;</span>group_by_list<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">HAVING</span>  <br>    <span class="hljs-operator">&lt;</span>having_condition<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>  <br>    <span class="hljs-operator">&lt;</span>order_by_condition<span class="hljs-operator">&gt;</span><br>LIMIT<br>    <span class="hljs-operator">&lt;</span>limit_params<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>执行顺序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">left</span> <span class="hljs-keyword">table</span><span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>join_condition<span class="hljs-operator">&gt;</span><br><span class="hljs-operator">&lt;</span><span class="hljs-keyword">join</span> type<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-operator">&lt;</span>right_table<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">WHERE</span> <span class="hljs-operator">&lt;</span>where_condition<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span>  <span class="hljs-operator">&lt;</span>group_by_list<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">HAVING</span> <span class="hljs-operator">&lt;</span>having_condition<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span>  <span class="hljs-operator">&lt;</span><span class="hljs-keyword">select</span> list<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>  <span class="hljs-operator">&lt;</span>order_by_condition<span class="hljs-operator">&gt;</span><br>LIMIT <span class="hljs-operator">&lt;</span>limit_params<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>正则表达式 regexp</p><p><img src="/asset/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/images/6.png" alt="正则表达式"></p>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 日志</title>
    <link href="/2020/04/20/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/%E6%97%A5%E5%BF%97/"/>
    <url>/2020/04/20/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h3 id="错误日志">错误日志</h3><p>记录服务器启动, 运行相关发生的严重的错误信息</p><pre><code class="hljs">show variables like &quot;log_error%&quot;；</code></pre><h3 id="binlog">binlog</h3><p>记录了所有DDL(数据定义语言)语句和DML(数据操作语言)语句, 但是不包括查询语句, 对容灾恢复, 主从复制有作用</p><p>默认不开启</p><p>需要在my.conf中配置</p><pre><code class="hljs"># 日志前缀 mysqlbin.00001 mysqlbin.00002log_bin=mysqlbinbin_log_format=STATMENT</code></pre><h4 id="日志格式">日志格式</h4><h5 id="STATMENT">STATMENT</h5><p>记录的都是SQL(不包括查询)语句 通过 mysqlbinlog 工具可以解析出SQL语句</p><h5 id="ROW">ROW</h5><p>记录的都是每一行数据的变更而不是SQL语句</p><h5 id="MIXED">MIXED</h5><p>Mysql 默认的日志格式<br>集成了STATMENT, ROW, 默认情况下采用STATMENT,  特殊情况下采用ROW<br>尽量利用他们的有点, 避免其缺点</p><p>mysqlbinlog 工具可以查看二进制日志文件</p><p>STATMENT格式下就可以查看的执行的SQL语句</p><pre><code class="hljs">mysqlbinlog log-file</code></pre><p>ROW格式下就可以查看的执行的SQL变更情况</p><pre><code class="hljs">mysqlbinlog -vv log-file</code></pre><h4 id="清除日志">清除日志</h4><ol><li><p>删除全部binlog日志, 日志编号从xxx.000001开始</p><p>mysql&gt; Reset Master</p></li><li><p><code>mysql&gt; purge master logs to &quot;xxxx.00000x&quot;</code> 删除日志00000x之前的所有日志</p></li><li><p><code>mysql&gt; purge master logs before &quot;yyyy-mm-dd hh24:mi:ss&quot;</code> 删除日志yyyy-mm-dd hh24:mi:ss之前的所有日志</p></li><li><p>–expire_logs_days=xx,日志过期时间 在my.conf配置</p></li></ol><h3 id="查询日志">查询日志</h3><p>明文显示数据库查询日志</p><p><img src="/asset/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/images/7.png" alt="avatar"></p><h3 id="慢查询日志">慢查询日志</h3><p>慢查询日志记录所有执行时间超过参数 long_query_time 设置值, 并且扫描记录不小于min_examined_wor_limit的所有的SQL语句的日志</p><p>long_query_time 默认是10s, 可以精确到微秒</p><p><img src="/asset/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/images/8.png" alt="avatar"></p>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 索引</title>
    <link href="/2020/04/20/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/%E7%B4%A2%E5%BC%95/"/>
    <url>/2020/04/20/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h4 id="聚簇索引与非聚簇索引b-树实现有什么区别">聚簇索引与非聚簇索引b+树实现有什么区别</h4><p>分为聚簇索引和非聚簇索引（有时也称辅助索引或二级索引）</p><p>聚簇是为了提高某个属性(或属性组)的查询速度, 把这个或这些属性(称为聚簇码)上具有相同值的元组集中存放在连续的物理块。</p><p>聚簇索引（clustered index）不是单独的一种索引类型, 而是一种数据存储方式。这种存储方式是依靠B+树来实现的, 根据表的主键构造一棵B+树且B+树叶子节点存放的都是表的行记录数据时, 方可称该主键索引为聚簇索引<br>。聚簇索引也可理解为将数据存储与索引放到了一块, 找到索引也就找到了数据。</p><p>非聚簇索引：数据和索引是分开的, B+树叶子节点存放的不是数据表的行记录</p><p>虽然InnoDB和MyISAM存储引擎都默认使用B+树结构存储索引, 但是只有InnoDB的主键索引才是聚簇索引,  InnoDB中的辅助索引以及MyISAM使用的都是非聚簇索引。每张表最多只能拥有一个聚簇索引。</p><h4 id="逻辑分类">逻辑分类</h4><p>key：等价普通索引 key 键名 (列)</p><p>主键索引primary key：</p><ul><li>约束作用（constraint）, 主键约束（unique, not null, 一表一主键, 唯一标识记录）, 规范存储主键和强调唯一性<br>为这个key建立主键索引</li></ul><p>单值(普通)索引：一个索引只包含单个列, 一个表可以有多个单列索引</p><p>唯一索引：索引列的值必须唯一, 但允许有空值</p><p>复合索引：一个索引可以包含多个列</p><p>全文索引</p><p>最左前缀法则(联合索引)<br>指的是, 查询从索引的最左前列开始, 不得跳过索引中的列</p><p>和 where 后面的先后条件没有关系</p><pre><code class="hljs">1,2,3where 1=xxx and 2=xxx, 3=xxx, 只走1, 2, 3 的索引where 1=xxx and 3=xxx,  只走1, 的索引where 1=xxx and 2=xxx   只走1, 2的索引where 1=xxx             只走1, 的索引where 2=xxx and 3 =xxx  只走2, 3 的索引where 2=xxx             只走2, 的索引where 3=xxx             只走3, 的索引</code></pre><p>索引失效的情况</p><ol><li><p>范围查询右边的列, 不使用索引<br><img src="/asset/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/images/9.png" alt="avatar"></p></li><li><p>不能在索引列上进行运算操作</p><p>例如 where substring(name, 3, 2) = “xxx” 即使创建了name的索引, 索引也会失效</p></li><li><p>字符串不加引号, 也会导致索引失效<br>where name = 1</p></li><li><p>尽量避开select(*), 尽量使用覆盖索引, 避免不必要的回表查询</p></li><li><p>用 or 前面的条件有索引, 后面的没有索引, 索引全部失效</p></li><li><p>以%开头的like 语句也会导致索引失效</p></li><li><p>如果使用索引比扫描全表更慢, 则不会走索引</p></li><li><p>数据量大小情况,  is NULL, is not NULL 也会导致索引失效</p></li><li><p>尽量使用复合索引, 少使用单列索引</p></li></ol><h4 id="数据结构">数据结构</h4><p>hash：是无序的值, 没有不能排序不能范围查找, 哈希冲突下, 需要比对, 会影响速度</p><p>平衡二叉树,  除叶子节点外, 其他节点必定是满的, 左子树, 右子树层级差不会超过1,  树越高查找速度越慢, 范围查找下, 回旋查找效率非常慢</p><p>B树</p><p>范围查找下, 回旋查找效率非常慢<br><img src="/asset/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/images/10.png" alt="avatar"></p>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 锁</title>
    <link href="/2020/04/20/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/%E9%94%81/"/>
    <url>/2020/04/20/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h4 id="锁概述">锁概述</h4><p>锁是计算机协调多个进程或者线程并发访问某一资源的机制（避免争抢）</p><h4 id="锁分类">锁分类</h4><p>从对数据操作的粒度分：</p><ol><li><p>表锁： 操作时, 锁定整张表</p></li><li><p>行锁： 操作时, 锁定当前操作行</p></li></ol><p>从对数据操作的类型分：</p><ol><li><p>读锁(共享锁)：正对同一份数据, 多个读操作可以同时进行而互不影响</p></li><li><p>写锁(排它锁)：当前操作没完成之前, 会阻塞其他读写操作</p></li></ol><h4 id="互斥锁">互斥锁</h4><p>互斥锁特点：<br>一次只能一个线程拥有互斥锁, 其他线程只有等待</p><h4 id="Mysql锁">Mysql锁</h4><p><img src="/asset/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/images/1.png" alt="avatar"></p><ul><li><a href="MyISAM.md">MyISAM</a></li><li><a href="InnoDB.md">InnoDB</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python GIL</title>
    <link href="/2020/04/15/Python/GIL/"/>
    <url>/2020/04/15/Python/GIL/</url>
    
    <content type="html"><![CDATA[<p>GIL是什么？</p><hr><p>GIL(全局解释器锁)是 Global Interpreter Lock 的缩写, 其作用是, 在Python使用多线程的时候, 所有的线程去抢一个锁, 抢到了锁的线程就可以获得CPU时间。<br>使用GIL的主要目的是为了简化Python解释器的实现（Python中的标准库里, 如无声明, 大部分库都不是并发安全的）, 而缺点就是无法充分的利用机器的多核</p><p>Python中如何使用多个CPU核心？</p><hr><p>应为GIL的存在, 为了使用多核, 就必须摆脱 GIL 的限制, 通常有这么几种方式：</p><p>使用多进程而不是多线程：对于CPU密集型任务，可以使用multiprocessing模块创建多个进程，每个进程拥有自己的解释器和独立的GIL。</p><p>使用异步编程：对于I/O密集型任务，可以使用协程和异步编程库（如asyncio）来避免GIL的限制，因为协程在等待I/O时可以释放GIL。</p><p>需要注意的是，虽然GIL在某些情况下会限制Python多线程的性能，但对于大多数应用程序来说，并不会成为瓶颈。Python中的许多标准库和第三方库都可以通过多进程、多线程或异步编程来实现并发，并在不同的应用场景中找到合适的解决方案。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 一些题目</title>
    <link href="/2020/04/15/Python/%E4%B8%80%E4%BA%9B%E9%A2%98%E7%9B%AE/"/>
    <url>/2020/04/15/Python/%E4%B8%80%E4%BA%9B%E9%A2%98%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="#%E7%BB%9F%E8%AE%A1%E9%A2%91%E6%AC%A1">统计频次</a></li><li><a href="#%E5%B0%8F%E5%86%85%E5%AD%98%E5%A4%84%E7%90%86%E5%A4%A7%E6%96%87%E4%BB%B6">小内存处理大文件</a></li><li><a href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E9%97%AE%E9%A2%98">默认参数问题</a></li><li><a href="#%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%84%E5%88%99">变量作用域规则</a></li></ul><h3 id="统计频次">统计频次</h3><p>如何统计一篇文章中单词的出现次数？</p><p>使用 Counter, 例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>In [<span class="hljs-number">1</span>]: a = <span class="hljs-string">&quot;hello world hello world world hello this that&quot;</span>                                                                                                                  <br><br>In [<span class="hljs-number">2</span>]: <span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter                                                                                                                                      <br><br>In [<span class="hljs-number">3</span>]: counter = Counter(a.split(<span class="hljs-string">&quot; &quot;</span>))                                                                                                                                      <br><br>In [<span class="hljs-number">4</span>]: counter                                                                                                                                                              <br>Out[<span class="hljs-number">4</span>]: Counter(&#123;<span class="hljs-string">&#x27;hello&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;world&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;this&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;that&#x27;</span>: <span class="hljs-number">1</span>&#125;)<br><br></code></pre></td></tr></table></figure><h3 id="小内存处理大文件">小内存处理大文件</h3><p>Python中如何读取一个大小为1G的纯文本的内容</p><p>这个题目主要是为了考察, Python中如何打开大文件。打开文件的时候, 如果直接读取所有文件内容, 那么就需要一个很大的数据结构例如 list 或者 str 来存储文件里的内容, 这对于很多小内存的设备往往是不可行的。因此, 此处面试官隐含了一个条件, 就是考察你是否能考虑到节省内存。</p><p>因此, 首先你需要跟面试官确认, 我需要考虑内存占用对吗？</p><p>然后, 一般面试官会给你肯定的回答。之后就到了我们提出解决方案的时候, 既然一次性读取大文件非常耗费内存, 解决方案就是分而治之, 例如, 逐行读取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;demo.txt&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    line = f.readline()<br>    <span class="hljs-keyword">while</span> line:<br>        <span class="hljs-built_in">print</span>(line)<br>        line = f.readline()<br></code></pre></td></tr></table></figure><p>或者我们使用一个 生成器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">read</span>(<span class="hljs-params">path</span>):<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(path) <span class="hljs-keyword">as</span> f:<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            line = f.readline()<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> line:<br>                <span class="hljs-keyword">break</span><br><br>            <span class="hljs-keyword">yield</span> line<br><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> read(<span class="hljs-string">&quot;demo.txt&quot;</span>):<br>    <span class="hljs-built_in">print</span>(i)<br><br></code></pre></td></tr></table></figure><h3 id="默认参数问题">默认参数问题</h3><p>这段代码会输出什么结果？为什么？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a=[]</span>):<br>    a.append(<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(a)<br><br><br>foo()<br>foo()<br>foo()<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">[1, 1][1, 1, 1]</code></pre><p>原因是, Python中的默认参数只会初始化一次, 并且会共享同一个对象。因此, 这里每次调用 foo , 其实都是操作同一个列表, 因此会产生上述输出。</p><h3 id="变量作用域规则">变量作用域规则</h3><p>解析：</p><p>Python中的变量作用域规则遵循 L-E-G-B 的顺序。其中：</p><ol><li>L 是指 Local, 指本地变量, 例如 def 或者 lambda 定义的函数体内的变量</li><li>E 是指 Enclosing-function locals, 即闭包变量</li><li>G 是指 Global, 全局变量</li><li>B 是指 Built-in 即Python解释器提供的内置函数和变量</li></ol><p>用一个例子来看看各个变量属于什么变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>hello = <span class="hljs-string">&quot;hello&quot;</span>  <span class="hljs-comment"># hello是全局变量</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>():<br>    <span class="hljs-built_in">print</span>(hello)  <span class="hljs-comment"># 这里的hello是引用了全局变量</span><br>    world = <span class="hljs-string">&quot;world&quot;</span>  <span class="hljs-comment"># 这里的world是局部变量</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bar</span>():<br>        message = <span class="hljs-string">&quot;message&quot;</span>  <span class="hljs-comment"># 这里的message也是局部变量</span><br>        <span class="hljs-built_in">print</span>(world)  <span class="hljs-comment"># 这里的world是闭包变量</span><br><br>    bar()<br><br>    <span class="hljs-comment"># 上面的 print 函数是builtin里提供的</span><br><br></code></pre></td></tr></table></figure><p>这段代码执行会报错吗？为什么？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">hello = <span class="hljs-string">&quot;hello&quot;</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>():<br>    <span class="hljs-built_in">print</span>(hello)<br>    hello = <span class="hljs-string">&quot;world&quot;</span><br>    <span class="hljs-built_in">print</span>(hello)<br><br>foo()<br></code></pre></td></tr></table></figure><p>会报错, 如下</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ <span class="hljs-keyword">python</span> demo.<span class="hljs-keyword">py</span><br>    Traceback (most recent <span class="hljs-keyword">call</span> <span class="hljs-keyword">last</span>):<br>    File <span class="hljs-string">&quot;demo.py&quot;</span>, <span class="hljs-built_in">line</span> <span class="hljs-number">10</span>, in <span class="hljs-symbol">&lt;module&gt;</span><br>        foo()<br>    File <span class="hljs-string">&quot;demo.py&quot;</span>, <span class="hljs-built_in">line</span> <span class="hljs-number">5</span>, in foo<br>        <span class="hljs-keyword">print</span>(hello)<br>    UnboundLocalError: local variable <span class="hljs-string">&#x27;hello&#x27;</span> referenced before assignment<br><br></code></pre></td></tr></table></figure><p>原因是在Python中, 只要出现赋值语句, 那么变量就会在与赋值语句所在的同级作用域查找, 其中赋值语句包括 =, def, class, import, del, for, as。而上面的例子中, 第一个 print(hello) 执行时, hello 这个变量会在本级作用域查找, 但是这个 print 执行的时候, hello 还没有被赋值, 所以找不到这个变量</p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>is 和 == 的区别</title>
    <link href="/2020/04/15/Python/is_or_==/"/>
    <url>/2020/04/15/Python/is_or_==/</url>
    
    <content type="html"><![CDATA[<hr><p>都是对象的比较</p><p>is 比较的是内存地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;<span class="hljs-number">1</span> <span class="hljs-keyword">is</span> <span class="hljs-number">1</span><br><span class="hljs-literal">True</span><br>&gt;&gt;&gt;[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] <span class="hljs-keyword">is</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br><span class="hljs-literal">False</span><br><span class="hljs-comment"># 因为 id([1, 2]) 都不同</span><br></code></pre></td></tr></table></figure><p>== 是两个对象的__eq__方法返回的值进行比较</p><p>因此可以重载__eq__来实现不同对象的比较</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NewInt</span>(<span class="hljs-title class_ inherited__">int</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(self) == <span class="hljs-built_in">str</span>(other)<br><br><br>ni = NewInt(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(ni == <span class="hljs-string">&quot;1&quot;</span>) <span class="hljs-comment"># True</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存管理与垃圾回收机制</title>
    <link href="/2020/04/15/Python/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/04/15/Python/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>内存管理与垃圾回收机制</p><hr><p>Python 的内存管理机制及调优手段？<br>内存管理机制：引用计数、垃圾回收、内存池。</p><h3 id="引用计数：">引用计数：</h3><p>引用计数是一种非常高效的内存管理手段,  当一个 Python 对象被引用时其引用计数增加 1,  当其不再被一个变量引用时则计数减 1. 当引用计数等于 0 时对象被删除。</p><h3 id="垃圾回收-：">垃圾回收 ：</h3><h4 id="1-引用计数">1.引用计数</h4><p>引用计数也是一种垃圾收集机制, 而且也是一种最直观, 最简单的垃圾收集技术。当 Python 的某个对象的引用计数降为 0 时, 说明没有任何引用指向该对象, 该对象就成为要被回收的垃圾了。比如某个新建对象, 它被分配给某个引用, 对象的引用计数变为 1。如果引用被删除, 对象的引用计数为 0,  那么该对象就可以被垃圾回收。不过如果出现循环引用的话, 引用计数机制就不再起有效的作用了</p><h4 id="2-标记清除">2.标记清除</h4><p>如果两个对象的引用计数都为 1, 但是仅仅存在他们之间的循环引用, 那么这两个对象都是需要被回收的, 也就是说, 它们的引用计数虽然表现为非 0, 但实际上有效的引用计数为 0。所以先将循环引用摘掉, 就会得出这两个对象的有效计数。</p><h4 id="3-分代回收">3.分代回收</h4><p>从前面“标记-清除”这样的垃圾收集机制来看, 这种垃圾收集机制所带来的额外操作实际上与系统中总的内存块的数量是相关的, 当需要回收的内存块越多时, 垃圾检测带来的额外操作就越多, 而垃圾回收带来的额外操作就越少；反之, 当需回收的内存块越少时, 垃圾检测就将比垃圾回收带来更少的额外操作。</p><h3 id="调优手段（了解）">调优手段（了解）</h3><ol><li>手动垃圾回收</li><li>调高垃圾回收阈值</li><li>避免循环引用（手动解循环引用和使用弱引用）</li></ol><h3 id="内存池">内存池</h3><p><img src="/asset/Python/images/12876717-bd79288a23142d3c.webp" alt="avatar"></p><p>Python的内存机制呈现金字塔形状：</p><ol><li><p>-1, -2层主要有操作系统进行操作；</p></li><li><p>第0层是C中的malloc, free等内存分配和释放函数进行操作；</p></li><li><p>第1层和第2层是内存池, 有Python的接口函数PyMem_Malloc函数实现, 当对象小于256K时有该层直接分配内存；</p></li><li><p>第3层是最上层, 也就是我们对Python对象的直接操作；</p></li></ol><h3 id="内存泄露是什么？如何避免？">内存泄露是什么？如何避免？</h3><p>指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况。内存泄漏并非指内存在物理上的消失, 而是应用程序分配某段内存后, 由于设计错误, 失去了对该段内存的控制, 因而造成了内存的浪费。导致程序运行速度减慢甚至系统崩溃等严重后果。</p><p>有 del () 函数的对象间的循环引用是导致内存泄漏的主凶。</p><p>不使用一个对象时使用:del object 来删除一个对象的引用计数就可以有效防止内存泄漏问题。通过 Python 扩展模块 gc 来查看不能回收的对象的详细信息。</p><p>可以通过 sys.getrefcount(obj) 来获取对象的引用计数, 并根据返回值是否为 0 来判断是否内存泄漏</p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>协程和线程</title>
    <link href="/2020/04/15/Python/%E5%8D%8F%E7%A8%8B/"/>
    <url>/2020/04/15/Python/%E5%8D%8F%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="迭代器">迭代器</h3><p>是一种可以遍历的对象，可以作用于next（）函数</p><h3 id="生成器">生成器</h3><p>Python中一边循环一边计算的机制称为生成器 比如生成器函数（yield ）</p><h3 id="装饰器">装饰器</h3><p>可以使用装饰器，装饰该函数，在不改变原函数的情况下，增加功能</p><h3 id="进程-线程和协程">进程,线程和协程</h3><hr><p><strong>进程</strong>在操作系统上运行的一个程序, 操作系统以进程为单位分配资源, 每个进程都有自己的地址空间、内存、数据栈以及其他用于跟踪进程执行的辅助数据, 操作系统管理所有进程的执行, 并为这些进程合理的分配资源</p><p><strong>线程</strong>是操作系统能够进行运算调度的最小单位, 被包含在进程之中, 是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流, 一个进程中可以并发多个线程, 每条线程并行执行不同的任务</p><ul><li>进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位</li><li>线程能减少并发执行的时间和空间开销</li><li>进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈</li></ul><p><strong>协程</strong>的作用, 是在执行函数A时, 可以随时中断, 去执行函数B, 然后中断继续执行函数A（可以自由切换）。但这一过程并不是函数调用（没有调用语句）, 这一整个过程看似像多线程, 然而协程只有一个线程执行。</p><h5 id="并发与并行">并发与并行</h5><p>并发通常指有多个任务需要同时进行, 并行则是同一时刻有多个任务执行。用多线程、多进程、协程来说, 协程实现并发, 多线程与多进程实现并行</p><p>多线程多个任务在同一时间执行</p><hr><h3 id="生成器变为协程">生成器变为协程</h3><hr><p>通过yield关键字和.send方法, 用户可以随时中断一个函数执行转而执行另一个函数, 相当于手动从一个子程序的执行切换到了另一个子程序的执行。在这种子程序的切换过程中没有涉及到线程的切换, 我们将一个子程序和它被执行以及被挂起时的状态称之为一个协程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">gg</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;a&#x27;</span>)<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        b = <span class="hljs-keyword">yield</span><br>        <span class="hljs-built_in">print</span>(b)<br>n = gg()<br>n.send(<span class="hljs-literal">None</span>) <span class="hljs-comment"># 预激活协程,让函数gg运行到b = yield这一句</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&#x27;</span>)<br>n.send(<span class="hljs-string">&#x27;b&#x27;</span>) <span class="hljs-comment"># 给函数gg中的yield传值</span><br>n.throw(Exception,<span class="hljs-string">&#x27;value error&#x27;</span>) <span class="hljs-comment"># 让调用方抛出异常, 在生成器中处理</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 子生成器</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">average_gen</span>():<br>    total = <span class="hljs-number">0</span><br>    count = <span class="hljs-number">0</span><br>    average = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        new_num = <span class="hljs-keyword">yield</span> average<br>        <span class="hljs-built_in">print</span>(new_num)<br>        count += <span class="hljs-number">1</span><br>        total += new_num<br>        average = total/count<br><br><span class="hljs-comment"># 委托生成器</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">proxy_gen</span>():<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> average_gen()<br><br><span class="hljs-comment"># 调用方</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    calc_average = proxy_gen()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(calc_average) )           <span class="hljs-comment"># 预激下生成器</span><br>    <span class="hljs-built_in">print</span>(calc_average.send(<span class="hljs-number">10</span>))  <span class="hljs-comment"># 打印：10.0</span><br>    <span class="hljs-built_in">print</span>(calc_average.send(<span class="hljs-number">20</span>))  <span class="hljs-comment"># 打印：15.0</span><br>    <span class="hljs-built_in">print</span>(calc_average.send(<span class="hljs-number">30</span>))  <span class="hljs-comment"># 打印：20.0</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><hr><h3 id="asyncio和future">asyncio和future</h3><hr><p>future对象由asyncio创建</p><p><font color=red>future表示终将发生的事情, 而确定某件事会发生的唯一方式就是执行的时间已经排定</font></p><p>future对象</p><p>future对象有四个状态：Pending、Running、Done、Cancelled。创建future的时候, task为pending, 事件循环调用执行的时候当然就是running, 调用完毕自然就是done, 如果需要停止事件循环, 就需要先把task取消, 可以使用asyncio.Task获取事件循环的task</p><p>asyncio协程如何实现并发</p><p>asyncio想要实现并发, 就需要多个协程来完成任务, 每当有任务阻塞的时候就await, 然后其他协程继续工作, 这需要创建多个协程的列表, 然后将这些协程注册到事件循环中。这里指的多个协程, 可以是多个协程函数, 也可以是一个协程函数的多个协程对象</p><h3 id="处理并发">处理并发</h3><p>Python中处理并发与大多数语言一样, 但也有不一样的地方。常见的处理并发的方式如下：</p><ol><li><p>使用进程池。即, 预先fork好一定数量的进程, 每来一个请求, 就从进程池中分配一个进程去处理该请求, 处理完成之后, 再将该进程放回进程池。这种方式的优点是可以充分利用多核, 但缺点同样明显, 就是比较浪费CPU, 因为多进程切换的时候由于要保存上下文, 需要更多的指令来保存更多的数据。而且进程比线程占用更多的内存。</p></li><li><p>使用线程池。与进程池工作原理类似, 但是每次是使用线程来处理请求。Python中使用线程池有一个比较大的缺点就是Python有GIL, 也就意味着, Python使用线程池无法充分利用多核。</p></li><li><p>使用协程。借助gevent这类工具, Python可以轻松的以同步的方式写出异步的代码, 从而可以轻松的处理并发问题, 同时配合使用进程池, 便可以充分利用多核, 并且借助event loop, 高效的处理I/O事件, 通常这都是Python中的最佳实践方案。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>闭包</title>
    <link href="/2020/04/15/Python/%E9%97%AD%E5%8C%85/"/>
    <url>/2020/04/15/Python/%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<p>闭包不是Python独有的概念, 闭包是指在函数中可以（嵌套）定义另一个函数时, 如果内部的函数引用了外部的函数的变量, 则可能产生闭包。运行时, 一旦外部的 函数被执行, 一个闭包就形成了, 闭包中包含了内部函数的代码, 以及所需外部函数中的变量的引用。</p><p>也就是说, 在函数中声明另一个函数, 里面的函数如果引用了外层函数中的变量, 那么就形成了一个闭包。例如：</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">In [1]</span><span class="hljs-punctuation">:</span> <span class="hljs-string">def foo(): </span><br>   <span class="hljs-attribute">...</span><span class="hljs-punctuation">:</span> <span class="hljs-string">    a = 1 </span><br>   <span class="hljs-attribute">...</span><span class="hljs-punctuation">:</span> <span class="hljs-string">    def bar(): </span><br>   <span class="hljs-attribute">...</span><span class="hljs-punctuation">:</span> <span class="hljs-string">        print(a) </span><br>   <span class="hljs-attribute">...</span><span class="hljs-punctuation">:</span> <span class="hljs-string">    bar() </span><br>   <span class="hljs-attribute">...</span><span class="hljs-punctuation">:             </span><br><span class="hljs-attribute">In [2]</span><span class="hljs-punctuation">:</span> <span class="hljs-string">foo()                              </span><br>1<br><br></code></pre></td></tr></table></figure><p>这个例子中, bar这个函数就是闭包函数, 它引用了 foo 函数中声明的变量 a</p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis 一些题目</title>
    <link href="/2020/04/14/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/%E4%B8%80%E4%BA%9B%E9%A2%98%E7%9B%AE/"/>
    <url>/2020/04/14/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/%E4%B8%80%E4%BA%9B%E9%A2%98%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="数据结构">数据结构</h3><h4 id="基本类型">基本类型</h4><pre><code class="hljs">string 字符串list 列表set 集合zset 有序集合hash 哈希表</code></pre><ul><li>String：如果存储数字的话，是用int类型的编码;如果存储非数字，小于等于39字节的字符串，是embstr；大于39个字节，则是raw编码。</li><li>List：如果列表的元素个数小于512个，列表每个元素的值都小于64字节（默认），使用ziplist编码，否则使用linkedlist编码</li><li>Hash：哈希类型元素个数小于512个，所有值小于64字节的话，使用ziplist编码,否则使用hashtable编码。</li><li>Set：如果集合中的元素都是整数且元素个数小于512个，使用intset编码，否则使用hashtable编码。</li><li>Zset：当有序集合的元素个数小于128个，每个元素的值小于64字节时，使用ziplist编码，否则使用skiplist（跳跃表）编码</li></ul><h4 id="特殊类型">特殊类型</h4><pre><code class="hljs">bitmap 位图hyperloglog 基数统计geospatial 地理位置stream 消息队列</code></pre><h3 id="优点">优点</h3><ul><li>在内存操作一切速度快</li><li>单线程, 没有上下文的切换</li></ul><h3 id="缺点">缺点</h3><ul><li>因为单线程, 不能利用cpu多核性能</li></ul><h3 id="持久化">持久化</h3><ul><li><p>RDB</p><ul><li>记录快照的方式</li><li>fork子进程-&gt; 定时并且到达触发修改次数写磁盘-&gt;dump.rdb</li><li>记录的是二进制数据，快照恢复舒服快，可能丢失数据</li></ul></li><li><p>AOF</p><ul><li>记录过程的方式</li><li>客户端修改命令-&gt;每秒/每个命令/不同步-&gt;appendonly.aof</li><li>记录的是redis命令，命令过多恢复比较慢，恢复完整性上比RDB高</li></ul></li></ul><p>redis4.0+ 使用混合模式通过，RDB全量持久化内存数据，AOF增量持久化修改命令，以保证数据的完整性</p>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git手册</title>
    <link href="/2020/03/04/git%E6%89%8B%E5%86%8C/git/"/>
    <url>/2020/03/04/git%E6%89%8B%E5%86%8C/git/</url>
    
    <content type="html"><![CDATA[<h3 id="本地项目和远程关联">本地项目和远程关联</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">git init<br><br>git remote add origin https://xxx/xx.git<br><br>git pull --rebase origin master<br></code></pre></td></tr></table></figure><h3 id="添加多个仓库并且提交-拉取代码">添加多个仓库并且提交,拉取代码</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">// 添加一个 remote=origin的仓库地址<br>git remote add origin https://github.com/xx.git<br><br>// 添加一个 remote=gitee的仓库地址<br>git remote add gitee https://gitee.com/xx.git<br><br>// 拉取remote=gitee的代码<br>git pull gitee master<br><br>// 提交remote=gitee的代码<br>git push gitee master<br></code></pre></td></tr></table></figure><h3 id="gitignore忘了添加忽略的文件导致提交了不需要的文件">.gitignore忘了添加忽略的文件导致提交了不需要的文件</h3><p><strong>.gitignore添加忽略的文件夹</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">// 从git中删除idea缓存<br>git rm --cached -r .idea // -r 表示递归<br><br>// 生成新的提交<br>git add .gitignore<br>git commit -m &quot;(gitignore commit and remove .idea)&quot;<br><br>// 提交<br>git push<br><br></code></pre></td></tr></table></figure><h3 id="用代理拉github代码">用代理拉github代码</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">// 指定 http 代理 github<br>git config --global http.https://github.com.proxy http://127.0.0.1:4780<br><br>// 拉取代码指定 https 代理 github<br>git clone https://github.com/xxxxx/xxxxx2.git --config http.proxy=http://127.0.0.1:4780<br><br>// 删除代理<br>git config --global --unset http.https://github.com.proxy<br></code></pre></td></tr></table></figure><h3 id="保存登录状态">保存登录状态</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global credential.helper &#x27;store&#x27;<br></code></pre></td></tr></table></figure><h3 id="使用强制重置回滚最新的提交">使用强制重置回滚最新的提交</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reset --hard HEAD^<br><br>//回退最近两个commit,代码放回到暂存区<br>git reset --soft HEAD~2<br></code></pre></td></tr></table></figure><h3 id="修改github-commit提交时间">修改github commit提交时间</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>// 新提交<br>GIT_COMMITTER_DATE=&quot;2023-01-01T12:00:00&quot; git commit -m &quot;update&quot;  --date=&quot;2023-01-01T12:00:00&quot;<br><br>// 最近一次commit<br>GIT_COMMITTER_DATE=&quot;2023-01-01T12:00:00&quot; git commit --amend --date=&quot;2023-01-01T12:00:00&quot; --no-edit<br><br></code></pre></td></tr></table></figure><h3 id="git-重做">git 重做</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">注意先后顺序</span><br>git revert HEAD<br></code></pre></td></tr></table></figure><h3 id="忽略提交文件">忽略提交文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git update-index --assume-unchanged etc/config_test.yaml<br><br>// 取消<br>git update-index --no-assume-unchanged etc/config_test.yaml<br></code></pre></td></tr></table></figure><h3 id="git-忽略https证书">git 忽略https证书</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">set GIT_SSL_NO_VERIFY=true<br></code></pre></td></tr></table></figure><h3 id="git-修改当前项目的邮箱和用户名">git 修改当前项目的邮箱和用户名</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config user.name &quot;maocatooo&quot;<br><br>git config user.email &quot;maocatzk@gmail.com&quot;<br></code></pre></td></tr></table></figure><h3 id="当前分支拉取指定commit的代码">当前分支拉取指定commit的代码</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git cherry-pick &lt;commit-id&gt;<br></code></pre></td></tr></table></figure><h3 id="给分支单独拉出来创建项目目录">给分支单独拉出来创建项目目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git worktree add &lt;dir-name&gt; &lt;branch-name&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>git手册</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
