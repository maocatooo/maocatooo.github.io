---
title: 操作系统一些概念
date: 2020-04-22
tags: [操作系统]
---

### 进程与线程的区别

做个简单的比喻：进程=火车, 线程=车厢

+ 线程在进程下行进（单纯的车厢无法运行）
+ 一个进程可以包含多个线程（一辆火车可以有多个车厢）
+ 不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车, 比如站点换乘）
+ 同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）
+ 进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）
+ 进程间不会相互影响, 一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车, 但是如果一列火车上中间的一节车厢着火了, 将影响到所有车厢）
+ 进程可以拓展到多机, 进程最多适合多核（不同火车可以开在多个轨道上, 同一火车的车厢不能在行进的不同的轨道上）
+ 进程使用的内存地址（洗手间）可以上锁, 即一个线程使用某些共享内存时, 其他线程必须等它结束, 才能使用这一块内存。（比如火车上的洗手间）－"互斥锁"
+ 进程使用的内存地址可以限定使用量（比如火车上的餐厅, 最多只允许多少人进入, 如果满了需要在门口等, 等有人出来了才能进去）－“信号量”


进程是系统进行资源调度和分配的基本单位——》实现操作系统的并发

线程是cpu调度的基本单位——〉实现进程内部的并发


### 同步与互斥
互斥就是线程A访问了一组数据, 线程BCD就不能同时访问这些数据, 直到A停止访问了
同步就是ABCD这些线程要约定一个执行的协调顺序。比如D要执行, B和C必须都得做完, 而B和C要开始, A必须先得做完

### 死锁产生的必要条件

产生死锁的的四个条件如下：互请不循
1、互斥条件：一个资源每次只能被一个进程使用；
2、请求与保持条件：一个进程因请求资源而阻塞时, 对已获得的资源保持不放；
3、不剥夺条件：进程已获得的资源, 在没使用完之前, 不能强行剥夺；
4、循环等待条件：多个进程之间形成一种互相循环等待资源的关系。
并发带来压力, 有的人或有的程序, 会因为承受不住压力而崩溃, 情绪崩溃和程序崩溃没什么两样。当然, 不论是做人还是写程序, 面对问题时, 正确的做法都应是采取策略, 解除死锁


### 计算机系统概述
1、操作系统是什么？

操作系统是计算机资源的管理者, 比如有处理机管理、存储器管理、文件管理、设备管理

2、中断与异常？

中断：也称外中断, 指来自CPU执行指令以外的事件发生, 如设备发出的I/O结束中断, 通常是与当前执行指令无关的事件

异常：也称内中断, 比如程序地址越界 , 有关。


3、大内核与微内核区别？

（联想单体架构和微服务的区别）

大内核的性能比微内核高

因为微内核这个模块运行在内核态, 其余模块运行在用户态, 在就导致需要经常内核态和用户态之间进行切换, 导致一定的性能损失


### 进程管理
什么是饥饿, 与死锁有什么差别？

饥饿：等待时间对进程的推进和响应带来明显的就是进程饥饿

与死锁的区别？

1. 进入饥饿的进程可以只有1个, 而死锁要大于等于两个

2. 饥饿进程可以是就绪状态, 而死锁必须是阻塞状态

Windows 下的内存是如何管理的？

分页管理

什么是内存管理？

内存管理的基本功能就是为待运行的程序分配内存, 并在使用结束后回收这些内存

分区法是一种简单的内存管理方式, 分为固定分区法、动态分区法
固定分区法：一旦分区分好, 分区的个数和大小都不再改变
动态分区法：根据作业的内存容量需求, 动态为作业划分一块连续的内存空间(分区)


### 一个程序从开始运行到结束的完整过程（四个过程）

预处理：条件编译, 头文件包含, 宏替换的处理, 生成.i文件。

编译：将预处理后的文件转换成汇编语言, 生成.s文件

汇编：汇编变为目标代码(机器代码)生成.o的文件

链接：连接目标代码,生成可执行程序


### 线程模型
这里以Linux为例。Linux历史上, 最开始使用的线程是LinuxThreads, 但LinuxThreads有些方面受限于内核的特性, 从而违背了SUSV3 Pthreads标准。即它要根据内核的特性来实现线程, 有些地方没有遵循统一的标准。后来IBM开发了NGPT(Next Generation POSIX Threads), 性能明显优于LinuxThreads, 人们曾把它当作LinuxThreads的继任者。但最后, 又有一个项目NPTL(Native POSIX Threads Library)出来后, 性能更优于NGPT。2002年NGPT项目停止开发, 我们现在用的Linux线程就是NPTL。

线程的实现曾有3种模型：

1.多对一(M:1)的用户级线程模型

2.一对一(1:1)的内核级线程模型

3.多对多(M:N)的两级线程模型

上面的x对y(x:y)即x个用户线程对应y个内核调度实体(Kernel Scheduling Entity, 这个是内核分配CPU的对象单位)。

LinuxThreads和NPTL都是采用一对一的线程模型, NGPT采用的是多对多的线程模型！！！